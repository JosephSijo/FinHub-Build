{"results":[{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\Dashboard-77mHvodX.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\EmergencyFundsTab-VfBln1SL.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\GoalsTracker-CDWKNqoN.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\InteractiveFinancialValue-BEaiqemc.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\InvestmentsTab-7b7ZOF_8.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\LiabilityDashboard-BEre0Oy9.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\LiabilityTab-Cihd-oaZ.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\TransactionList-C9g51JND.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\charts--ivomIfj.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\forms-CLJ1xqyy.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\haptics-C9gh8PRt.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\index-DHabN7TV.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\motion-BWOTBQax.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\slider-COM-Y3un.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\tooltip-vw99S11h.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\ui-Ce9YeQZa.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\assets\\vendor-Cgg2GOmP.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\registerSW.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\sw.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\dist_test\\workbox-8c29f6e4.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\postcss.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\AIAssistant.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\AccountsManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\AchievementDetailDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\AchievementsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\CurrencyConverter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\DebtPayoffSimulator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\EmergencyFundsTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\EnhancedSettingsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\FundAllocationDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\GoalsTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\InsightsCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\InvestmentsTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\LiabilityDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\LiabilityTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\LoadingSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\MoreTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\NotificationsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\PullToRefresh.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\QuoteOfTheDay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\RecurringTransactions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\RecurringWidget.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadRecurring'. Either include it or remove the dependency array.","line":23,"column":6,"nodeType":"ArrayExpression","endLine":23,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [loadRecurring, userId]","fix":{"range":[821,829],"text":"[loadRecurring, userId]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\RoundUpDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\SubscriptionStrategist.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\TransactionForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\TransactionList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\TransferForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\WealthBuilderSimulator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\auth\\LoginScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\AdvancedInsights.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\FilterBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\TacticalRecovery.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\TimeRangeFilter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\dashboard\\TruthBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\figma\\ImageWithFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\investments\\InvestmentList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\investments\\PortfolioAllocationChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\investments\\PortfolioSummaryCards.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\investments\\PortfolioTransactionSummary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\layout\\AppHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\layout\\BottomNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\layout\\FabStack.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\layout\\ScrollAwareLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\liabilities\\DebtPayoffChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\onboarding\\OnboardingFlow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\overlays\\AIChatOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\overlays\\AboutUsPopup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\transactions\\TransactionFilters.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\transactions\\TransactionItems.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\transactions\\TransactionOverview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\transactions\\utils.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\CardPattern.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\CategoryBackdrop.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\CollapsibleCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\CollapsibleSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\CyberButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\InteractiveFinancialValue.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\LoadingSprite.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\MeshBackground.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\SwipeableItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\badge.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":46,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":46,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"./utils\";\r\n\r\nconst badgeVariants = cva(\r\n  \"inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default:\r\n          \"border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90\",\r\n        secondary:\r\n          \"border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90\",\r\n        destructive:\r\n          \"border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\r\n        outline:\r\n          \"text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nfunction Badge({\r\n  className,\r\n  variant,\r\n  asChild = false,\r\n  ...props\r\n}: React.ComponentProps<\"span\"> &\r\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\r\n  const Comp = asChild ? Slot : \"span\";\r\n\r\n  return (\r\n    <Comp\r\n      data-slot=\"badge\"\r\n      className={cn(badgeVariants({ variant }), className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nexport { Badge, badgeVariants };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":58,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":58,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"./utils\";\r\n\r\nconst buttonVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-xl text-sm font-medium transition-all active:scale-[0.97] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-primary text-primary-foreground hover:bg-primary/90\",\r\n        destructive:\r\n          \"bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60\",\r\n        outline:\r\n          \"border bg-background text-foreground hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50\",\r\n        secondary:\r\n          \"bg-secondary text-secondary-foreground hover:bg-secondary/80\",\r\n        ghost:\r\n          \"hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50\",\r\n        link: \"text-primary underline-offset-4 hover:underline\",\r\n      },\r\n      size: {\r\n        default: \"h-11 px-6 py-2 has-[>svg]:px-4\",\r\n        sm: \"h-9 gap-1.5 px-3 has-[>svg]:px-2.5\",\r\n        lg: \"h-12 px-8 has-[>svg]:px-6\",\r\n        icon: \"size-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nconst Button = React.forwardRef<\r\n  HTMLButtonElement,\r\n  React.ComponentProps<\"button\"> &\r\n  VariantProps<typeof buttonVariants> & {\r\n    asChild?: boolean;\r\n  }\r\n>(({ className, variant, size, asChild = false, ...props }, ref) => {\r\n  const Comp = asChild ? Slot : \"button\";\r\n\r\n  return (\r\n    <Comp\r\n      ref={ref}\r\n      data-slot=\"button\"\r\n      className={cn(buttonVariants({ variant, size, className }))}\r\n      {...props}\r\n    />\r\n  );\r\n});\r\n\r\nButton.displayName = \"Button\";\r\n\r\nexport { Button, buttonVariants };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\form.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":160,"column":3,"nodeType":"Identifier","messageId":"namedExport","endLine":160,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport * as LabelPrimitive from \"@radix-ui/react-label\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport {\r\n  Controller,\r\n  FormProvider,\r\n  useFormContext,\r\n  useFormState,\r\n  type ControllerProps,\r\n  type FieldPath,\r\n  type FieldValues,\r\n} from \"react-hook-form\";\r\n\r\nimport { cn } from \"./utils\";\r\nimport { Label } from \"./label\";\r\n\r\nconst Form = FormProvider;\r\n\r\ntype FormFieldContextValue<\r\n  TFieldValues extends FieldValues = FieldValues,\r\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\r\n> = {\r\n  name: TName;\r\n};\r\n\r\nconst FormFieldContext = React.createContext<FormFieldContextValue>(\r\n  {} as FormFieldContextValue,\r\n);\r\n\r\nconst FormField = <\r\n  TFieldValues extends FieldValues = FieldValues,\r\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\r\n>({\r\n  ...props\r\n}: ControllerProps<TFieldValues, TName>) => {\r\n  return (\r\n    <FormFieldContext.Provider value={{ name: props.name }}>\r\n      <Controller {...props} />\r\n    </FormFieldContext.Provider>\r\n  );\r\n};\r\n\r\nconst useFormField = () => {\r\n  const fieldContext = React.useContext(FormFieldContext);\r\n  const itemContext = React.useContext(FormItemContext);\r\n  const { getFieldState } = useFormContext();\r\n  const formState = useFormState({ name: fieldContext.name });\r\n  const fieldState = getFieldState(fieldContext.name, formState);\r\n\r\n  if (!fieldContext) {\r\n    throw new Error(\"useFormField should be used within <FormField>\");\r\n  }\r\n\r\n  const { id } = itemContext;\r\n\r\n  return {\r\n    id,\r\n    name: fieldContext.name,\r\n    formItemId: `${id}-form-item`,\r\n    formDescriptionId: `${id}-form-item-description`,\r\n    formMessageId: `${id}-form-item-message`,\r\n    ...fieldState,\r\n  };\r\n};\r\n\r\ntype FormItemContextValue = {\r\n  id: string;\r\n};\r\n\r\nconst FormItemContext = React.createContext<FormItemContextValue>(\r\n  {} as FormItemContextValue,\r\n);\r\n\r\nfunction FormItem({ className, ...props }: React.ComponentProps<\"div\">) {\r\n  const id = React.useId();\r\n\r\n  return (\r\n    <FormItemContext.Provider value={{ id }}>\r\n      <div\r\n        data-slot=\"form-item\"\r\n        className={cn(\"grid gap-2\", className)}\r\n        {...props}\r\n      />\r\n    </FormItemContext.Provider>\r\n  );\r\n}\r\n\r\nfunction FormLabel({\r\n  className,\r\n  ...props\r\n}: React.ComponentProps<typeof LabelPrimitive.Root>) {\r\n  const { error, formItemId } = useFormField();\r\n\r\n  return (\r\n    <Label\r\n      data-slot=\"form-label\"\r\n      data-error={!!error}\r\n      className={cn(\"data-[error=true]:text-destructive\", className)}\r\n      htmlFor={formItemId}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nfunction FormControl({ ...props }: React.ComponentProps<typeof Slot>) {\r\n  const { error, formItemId, formDescriptionId, formMessageId } =\r\n    useFormField();\r\n\r\n  return (\r\n    <Slot\r\n      data-slot=\"form-control\"\r\n      id={formItemId}\r\n      aria-describedby={\r\n        !error\r\n          ? `${formDescriptionId}`\r\n          : `${formDescriptionId} ${formMessageId}`\r\n      }\r\n      aria-invalid={!!error}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nfunction FormDescription({ className, ...props }: React.ComponentProps<\"p\">) {\r\n  const { formDescriptionId } = useFormField();\r\n\r\n  return (\r\n    <p\r\n      data-slot=\"form-description\"\r\n      id={formDescriptionId}\r\n      className={cn(\"text-muted-foreground text-sm\", className)}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nfunction FormMessage({ className, ...props }: React.ComponentProps<\"p\">) {\r\n  const { error, formMessageId } = useFormField();\r\n  const body = error ? String(error?.message ?? \"\") : props.children;\r\n\r\n  if (!body) {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <p\r\n      data-slot=\"form-message\"\r\n      id={formMessageId}\r\n      className={cn(\"text-destructive text-sm\", className)}\r\n      {...props}\r\n    >\r\n      {body}\r\n    </p>\r\n  );\r\n}\r\n\r\nexport {\r\n  useFormField,\r\n  Form,\r\n  FormItem,\r\n  FormLabel,\r\n  FormControl,\r\n  FormDescription,\r\n  FormMessage,\r\n  FormField,\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\number-input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\theme-provider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\toggle-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\toggle.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":47,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":47,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\";\r\nimport { cva, type VariantProps } from \"class-variance-authority\";\r\n\r\nimport { cn } from \"./utils\";\r\n\r\nconst toggleVariants = cva(\r\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap\",\r\n  {\r\n    variants: {\r\n      variant: {\r\n        default: \"bg-transparent\",\r\n        outline:\r\n          \"border border-input bg-transparent hover:bg-accent hover:text-accent-foreground\",\r\n      },\r\n      size: {\r\n        default: \"h-9 px-2 min-w-9\",\r\n        sm: \"h-8 px-1.5 min-w-8\",\r\n        lg: \"h-10 px-2.5 min-w-10\",\r\n      },\r\n    },\r\n    defaultVariants: {\r\n      variant: \"default\",\r\n      size: \"default\",\r\n    },\r\n  },\r\n);\r\n\r\nfunction Toggle({\r\n  className,\r\n  variant,\r\n  size,\r\n  ...props\r\n}: React.ComponentProps<typeof TogglePrimitive.Root> &\r\n  VariantProps<typeof toggleVariants>) {\r\n  return (\r\n    <TogglePrimitive.Root\r\n      data-slot=\"toggle\"\r\n      className={cn(toggleVariants({ variant, size, className }))}\r\n      {...props}\r\n    />\r\n  );\r\n}\r\n\r\nexport { Toggle, toggleVariants };\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\use-mobile.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\components\\ui\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\context\\FinanceContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":162,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":162,"endColumn":24},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'updateSettings' function makes the dependencies of useCallback Hook (at line 486) change on every render. To fix this, wrap the definition of 'updateSettings' in its own useCallback() Hook.","line":1040,"column":11,"nodeType":"VariableDeclarator","endLine":1063,"endColumn":6,"suggestions":[{"desc":"Wrap the definition of 'updateSettings' in its own useCallback() Hook.","fix":{"range":[46125,47110],"text":"useCallback(async (updates: Partial<UserSettings>) => {\r\n        // Optimistic update\r\n        const newSettings = { ...settings, ...updates };\r\n        setSettings(newSettings);\r\n        if (updates.theme) applyTheme(updates.theme);\r\n\r\n        try {\r\n            const response = await api.updateSettings(userId, updates);\r\n            if (response.success) {\r\n                // Merge response with existing state to avoid losing local-only fields\r\n                setSettings(prev => ({\r\n                    ...prev,\r\n                    ...response.settings,\r\n                    aiProvider: response.settings.aiProvider || prev.aiProvider,\r\n                    apiKeys: { ...prev.apiKeys, ...response.settings.apiKeys }\r\n                }));\r\n            } else {\r\n                throw new Error(response.error);\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Failed to sync settings\", error);\r\n            toast.error(\"Settings saved locally only\");\r\n        }\r\n    })"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'updateSettings' function makes the dependencies of useEffect Hook (at line 491) change on every render. To fix this, wrap the definition of 'updateSettings' in its own useCallback() Hook.","line":1040,"column":11,"nodeType":"VariableDeclarator","endLine":1063,"endColumn":6,"suggestions":[{"desc":"Wrap the definition of 'updateSettings' in its own useCallback() Hook.","fix":{"range":[46125,47110],"text":"useCallback(async (updates: Partial<UserSettings>) => {\r\n        // Optimistic update\r\n        const newSettings = { ...settings, ...updates };\r\n        setSettings(newSettings);\r\n        if (updates.theme) applyTheme(updates.theme);\r\n\r\n        try {\r\n            const response = await api.updateSettings(userId, updates);\r\n            if (response.success) {\r\n                // Merge response with existing state to avoid losing local-only fields\r\n                setSettings(prev => ({\r\n                    ...prev,\r\n                    ...response.settings,\r\n                    aiProvider: response.settings.aiProvider || prev.aiProvider,\r\n                    apiKeys: { ...prev.apiKeys, ...response.settings.apiKeys }\r\n                }));\r\n            } else {\r\n                throw new Error(response.error);\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Failed to sync settings\", error);\r\n            toast.error(\"Settings saved locally only\");\r\n        }\r\n    })"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'createRecurringTransaction' function makes the dependencies of useCallback Hook (at line 721) change on every render. To fix this, wrap the definition of 'createRecurringTransaction' in its own useCallback() Hook.","line":1185,"column":11,"nodeType":"VariableDeclarator","endLine":1304,"endColumn":6,"suggestions":[{"desc":"Wrap the definition of 'createRecurringTransaction' in its own useCallback() Hook.","fix":{"range":[54314,61369],"text":"useCallback(async (data: any) => {\r\n        try {\r\n            console.log(\"[Backfill Debug] createRecurringTransaction called with:\", data);\r\n            const response = await api.createRecurring(userId, data);\r\n            if (response.success) {\r\n                const newRec = response.recurring;\r\n                setRecurringTransactions(prev => [...prev, newRec]);\r\n                toast.success('Recurring transaction created');\r\n\r\n                // Auto-Backfill Logic (Timezone-Safe Refactor)\r\n                if (newRec.startDate) {\r\n                    console.log(\"[Backfill Debug] Analysis starting for:\", newRec.description || newRec.source);\r\n                    toast.info(\"Analyzing transaction history...\");\r\n\r\n                    const localNow = new Date();\r\n                    const nowStr = `${localNow.getFullYear()}-${String(localNow.getMonth() + 1).padStart(2, '0')}-${String(localNow.getDate()).padStart(2, '0')}`;\r\n                    const startStr = newRec.startDate.split('T')[0];\r\n\r\n                    console.log(\"[Backfill Debug] nowStr:\", nowStr, \"startStr:\", startStr);\r\n\r\n                    if (startStr <= nowStr && newRec.type) {\r\n                        const [sY, sM, sD] = startStr.split('-').map(Number);\r\n                        const current = new Date(sY, sM - 1, sD, 12, 0, 0);\r\n                        const dueDates: Date[] = [];\r\n                        let safety = 0;\r\n\r\n                        while (safety < 1200) {\r\n                            const cY = current.getFullYear();\r\n                            const cM = current.getMonth();\r\n                            const cD = current.getDate();\r\n                            const currentStr = `${cY}-${String(cM + 1).padStart(2, '0')}-${String(cD).padStart(2, '0')}`;\r\n                            if (currentStr > nowStr) break;\r\n                            dueDates.push(new Date(current));\r\n\r\n                            switch (newRec.frequency) {\r\n                                case 'daily': current.setDate(current.getDate() + 1); break;\r\n                                case 'weekly': current.setDate(current.getDate() + 7); break;\r\n                                case 'monthly': {\r\n                                    const origDay = sD;\r\n                                    current.setMonth(current.getMonth() + 1);\r\n                                    if (current.getDate() < origDay && current.getMonth() === (cM + 2) % 12) {\r\n                                        current.setDate(0);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                case 'yearly': current.setFullYear(current.getFullYear() + 1); break;\r\n                                case 'custom':\r\n                                    current.setDate(current.getDate() + (newRec.customIntervalDays || 30));\r\n                                    break;\r\n                                default: current.setMonth(current.getMonth() + 1);\r\n                            }\r\n                            safety++;\r\n                        }\r\n\r\n                        console.log(\"[Backfill Debug] Generated\", dueDates.length, \"due dates\");\r\n\r\n                        const recAmount = Number(newRec.amount);\r\n                        const recDesc = (newRec.description || newRec.source || '').toLowerCase().trim();\r\n\r\n                        const missingDates = dueDates.filter(due => {\r\n                            const dStr = `${due.getFullYear()}-${String(due.getMonth() + 1).padStart(2, '0')}-${String(due.getDate()).padStart(2, '0')}`;\r\n\r\n                            const exists = [...expenses, ...incomes].some(tx => {\r\n                                const txDate = (tx.date || '').split('T')[0];\r\n                                const txAmount = Number(tx.amount);\r\n                                const txDesc = (('description' in tx ? tx.description : (tx as any).source) || '').toLowerCase().trim();\r\n\r\n                                const amountMatch = Math.abs(txAmount - recAmount) < 0.01;\r\n                                const descMatch = txDesc.includes(recDesc) || recDesc.includes(txDesc);\r\n\r\n                                // Frequency-aware date matching\r\n                                let dateMatch = txDate === dStr;\r\n                                if (newRec.frequency === 'monthly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getDate() - due.getDate());\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear() &&\r\n                                        tDate.getMonth() === due.getMonth() &&\r\n                                        diff <= 7;\r\n                                } else if (newRec.frequency === 'weekly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getTime() - due.getTime()) / (1000 * 60 * 60 * 24);\r\n                                    dateMatch = diff <= 3;\r\n                                } else if (newRec.frequency === 'yearly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear();\r\n                                }\r\n\r\n                                // Link matching\r\n                                const linkMatch = tx.recurringId === newRec.id;\r\n\r\n                                return (descMatch || linkMatch) && dateMatch && amountMatch;\r\n                            });\r\n                            return !exists;\r\n                        });\r\n\r\n                        console.log(`[Backfill Debug] Total Expected: ${dueDates.length}, Missing: ${missingDates.length}`);\r\n\r\n                        if (missingDates.length > 0) {\r\n                            console.log(\"[Backfill Debug] Triggering popup request for\", missingDates.length, \"dates\");\r\n                            setBackfillRequest({\r\n                                count: missingDates.length,\r\n                                dates: missingDates,\r\n                                recurring: newRec\r\n                            });\r\n                        } else {\r\n                            console.log(\"[Backfill Debug] All expected entries already exist in history.\");\r\n                            toast.success(\"Transaction history is already up to date.\");\r\n                        }\r\n                    } else {\r\n                        console.log(\"[Backfill Debug] Skip: start date is in the future or invalid type.\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.error('Error creating recurring transaction:', error);\r\n            const temp = { id: `temp_${Date.now()}`, ...data, createdAt: new Date().toISOString() };\r\n            setRecurringTransactions(prev => [...prev, temp]);\r\n            toast.warning('Offline: Created locally');\r\n        }\r\n    })"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext, useContext, useState, useEffect } from 'react';\r\nimport { api } from '../utils/api';\r\nimport { toast } from 'sonner';\r\nimport confetti from 'canvas-confetti';\r\nimport {\r\n    Expense,\r\n    Income,\r\n    Debt,\r\n    Goal,\r\n    UserSettings,\r\n    Account,\r\n    Notification,\r\n    Investment,\r\n    CURRENCY_SYMBOLS,\r\n    Liability,\r\n    RecurringTransaction,\r\n    AuthUser\r\n} from '../types';\r\nimport { checkAchievements, getAchievement } from '../utils/achievements';\r\nimport { generateGurujiInsights, createInsightNotification } from '../utils/insights';\r\nimport { autoCategorize, isKnownSubscription } from '../utils/autoCategorize';\r\nimport { LocalNotifications } from '@capacitor/local-notifications';\r\nimport { Capacitor } from '@capacitor/core';\r\nimport { App } from '@capacitor/app';\r\n\r\n// Constants for LocalStorage keys\r\nconst STORAGE_KEYS = {\r\n    SETTINGS: 'finhub_settings',\r\n    EXPENSES: 'finhub_expenses',\r\n    INCOMES: 'finhub_incomes',\r\n    DEBTS: 'finhub_debts',\r\n    GOALS: 'finhub_goals',\r\n    ACCOUNTS: 'finhub_accounts',\r\n    INVESTMENTS: 'finhub_investments',\r\n    LIABILITIES: 'finhub_liabilities',\r\n    NOTIFICATIONS: 'finhub_notifications',\r\n    EMERGENCY_FUND: 'finhub_emergency_fund',\r\n    RECURRING: 'finhub_recurring',\r\n    AUTH: 'finhub_auth',\r\n    REMEMBERED_MOBILE: 'finhub_remembered_mobile',\r\n    DELETION_SCHEDULE: 'finhub_deletion_schedule'\r\n};\r\n\r\ninterface FinanceContextType {\r\n    // State\r\n    userId: string;\r\n    settings: UserSettings;\r\n    currency: string; // Add currency directly for easier access\r\n    expenses: Expense[];\r\n    incomes: Income[];\r\n    debts: Debt[];\r\n    goals: Goal[];\r\n    accounts: Account[];\r\n    investments: Investment[];\r\n    liabilities: Liability[];\r\n    recurringTransactions: RecurringTransaction[];\r\n    notifications: Notification[];\r\n    emergencyFundAmount: number;\r\n    isLoading: boolean;\r\n    isRefreshing: boolean;\r\n    isOffline: boolean;\r\n    apiStatus: 'online' | 'offline' | 'error';\r\n    pendingMobile: string;\r\n    authMessage?: { message: string, subMessage?: string };\r\n\r\n    // Auth State\r\n    authStatus: 'guest' | 'authenticating' | 'authenticated';\r\n    currentUser: AuthUser | null;\r\n    isAwaitingPin: boolean;\r\n    isRememberedUser: boolean;\r\n    rememberedMobile: string;\r\n\r\n    // Actions\r\n    refreshData: () => Promise<void>;\r\n    updateSettings: (updates: Partial<UserSettings>) => Promise<void>;\r\n\r\n    // Auth Actions\r\n    checkIdentity: (mobile: string) => Promise<boolean>;\r\n    login: (pin: string, rememberMe?: boolean) => Promise<boolean>;\r\n    signup: (mobile: string, pin: string, name: string, rememberMe?: boolean) => Promise<boolean>;\r\n    sendOtp: (mobile: string) => Promise<boolean>;\r\n    verifyOtp: (mobile: string, otp: string) => Promise<boolean>;\r\n    resetPin: (mobile: string, newPin: string) => Promise<boolean>;\r\n    logout: () => void;\r\n    clearPendingSession: () => void;\r\n    scheduleAccountDeletion: () => Promise<void>;\r\n    cancelAccountDeletion: () => Promise<void>;\r\n    deletionDate: string | null;\r\n\r\n    // CRUD Actions\r\n    createExpense: (data: any) => Promise<void>;\r\n    updateExpense: (id: string, data: any) => Promise<void>;\r\n    deleteExpense: (id: string) => Promise<void>;\r\n\r\n    createIncome: (data: any) => Promise<void>;\r\n    updateIncome: (id: string, data: any) => Promise<void>;\r\n    deleteIncome: (id: string) => Promise<void>;\r\n\r\n    createDebt: (data: any) => Promise<void>;\r\n    updateDebt: (id: string, data: any) => Promise<void>;\r\n    deleteDebt: (id: string) => Promise<void>;\r\n    settleDebt: (id: string) => Promise<void>;\r\n\r\n    createGoal: (data: any) => Promise<void>;\r\n    updateGoal: (id: string, data: any) => Promise<void>;\r\n    deleteGoal: (id: string) => Promise<void>;\r\n\r\n    createAccount: (data: any) => Promise<void>;\r\n    updateAccount: (id: string, data: any) => Promise<void>;\r\n    deleteAccount: (id: string) => Promise<void>;\r\n\r\n    // Liabilities\r\n    createLiability: (data: Omit<Liability, 'id'>) => Promise<void>;\r\n    updateLiability: (id: string, data: Partial<Liability>) => Promise<void>;\r\n    deleteLiability: (id: string) => Promise<void>;\r\n\r\n    // Migration\r\n    migrateSubscriptions: () => Promise<{ count: number }>;\r\n    cleanupDuplicates: () => Promise<{ count: number }>;\r\n\r\n    // Investments\r\n    createInvestment: (data: any, sourceAccountId?: string) => Promise<void>;\r\n    updateInvestment: (id: string, data: any) => Promise<void>;\r\n    deleteInvestment: (id: string) => Promise<void>;\r\n\r\n    // Recurring\r\n    createRecurringTransaction: (data: any) => Promise<void>;\r\n    updateRecurringTransaction: (id: string, data: any) => Promise<void>;\r\n    createRecurring: (data: any) => Promise<void>;\r\n    deleteRecurringTransaction: (id: string) => Promise<void>;\r\n    processRecurringTransactions: () => Promise<void>;\r\n\r\n    setEmergencyFundAmount: (amount: number | ((prev: number) => number)) => void; // Allow direct setting for now to match App.tsx usage\r\n    setNotifications: React.Dispatch<React.SetStateAction<Notification[]>>; // Expose setter for now\r\n\r\n    // Helpers\r\n    applyTheme: (theme: \"light\" | \"dark\" | \"system\") => void;\r\n\r\n    // Fund Allocation\r\n    isFundAllocationOpen: boolean;\r\n    fundAllocationType: 'goal' | 'emergency';\r\n    openFundAllocation: (type: 'goal' | 'emergency') => void;\r\n    closeFundAllocation: () => void;\r\n    performFundAllocation: (data: {\r\n        accountId: string;\r\n        destinationId: string;\r\n        amount: number;\r\n        destinationType: 'goal' | 'emergency';\r\n    }) => Promise<void>;\r\n    deductFromAccount: (accountId: string, amount: number) => Promise<void>;\r\n    transferFunds: (sourceId: string, destinationId: string, amount: number) => Promise<void>;\r\n    clearAllData: () => Promise<void>;\r\n\r\n    // Backfill Logic\r\n    backfillRequest: { count: number; dates: Date[]; recurring: any } | null;\r\n    setBackfillRequest: React.Dispatch<React.SetStateAction<{ count: number; dates: Date[]; recurring: any } | null>>;\r\n    executeBackfill: () => Promise<void>;\r\n}\r\n\r\nconst FinanceContext = createContext<FinanceContextType | undefined>(undefined);\r\n\r\nexport const useFinance = () => {\r\n    const context = useContext(FinanceContext);\r\n    if (!context) {\r\n        throw new Error('useFinance must be used within a FinanceProvider');\r\n    }\r\n    return context;\r\n};\r\n\r\nexport const FinanceProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n    const [userId] = useState(\"demo-user-001\");\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [isRefreshing, setIsRefreshing] = useState(false);\r\n\r\n    // Data State\r\n    const [settings, setSettings] = useState<UserSettings>({\r\n        theme: \"system\",\r\n        currency: \"INR\",\r\n        unlockedAchievements: [],\r\n        name: \"\",\r\n        photoURL: \"\",\r\n        notificationsEnabled: false,\r\n        roundUpEnabled: true,\r\n        aiProvider: \"openai\",\r\n        onboardingPhase: 0,\r\n        passiveIncomeTarget: 0,\r\n        isSampleMode: false,\r\n    });\r\n    const [expenses, setExpenses] = useState<Expense[]>([]);\r\n    const [incomes, setIncomes] = useState<Income[]>([]);\r\n    const [debts, setDebts] = useState<Debt[]>([]);\r\n    const [goals, setGoals] = useState<Goal[]>([]);\r\n    const [accounts, setAccounts] = useState<Account[]>([]);\r\n    const [investments, setInvestments] = useState<Investment[]>([]);\r\n    const [liabilities, setLiabilities] = useState<Liability[]>([]);\r\n    const [recurringTransactions, setRecurringTransactions] = useState<RecurringTransaction[]>([]);\r\n    const [notifications, setNotifications] = useState<Notification[]>([]);\r\n    const [emergencyFundAmount, setEmergencyFundAmount] = useState(0);\r\n    const [isOffline, setIsOffline] = useState(false);\r\n    const [apiStatus, setApiStatus] = useState<'online' | 'offline' | 'error'>('online');\r\n\r\n    // Auth State\r\n    const [authStatus, setAuthStatus] = useState<'guest' | 'authenticating' | 'authenticated'>('guest');\r\n    const [currentUser, setCurrentUser] = useState<AuthUser | null>(null);\r\n    const [isAwaitingPin, setIsAwaitingPin] = useState(false);\r\n    const [pendingMobile, setPendingMobile] = useState('');\r\n    const [isRememberedUser, setIsRememberedUser] = useState(false);\r\n    const [rememberedMobile, setRememberedMobile] = useState('');\r\n    const [deletionDate, setDeletionDate] = useState<string | null>(null);\r\n    const [generatedOtp, setGeneratedOtp] = useState<string | null>(null);\r\n    const [authMessage, setAuthMessage] = useState<{ message: string, subMessage?: string } | undefined>();\r\n    const [backfillRequest, setBackfillRequest] = useState<{ count: number; dates: Date[]; recurring: any } | null>(null);\r\n\r\n    // Pre-defined users for Beta/Demo\r\n    const DEMO_USERS = [\r\n        {\r\n            mobile: '9447147230',\r\n            pin: '2255',\r\n            name: 'tin2mon FinHub Node // 0x50.3',\r\n            userId: 'tin2mon-prod-001'\r\n        }\r\n    ];\r\n\r\n    // Notification Helper with Deduplication and Pruning\r\n    const addNotifications = React.useCallback((newNotifs: Notification | Notification[]) => {\r\n        const toAdd = Array.isArray(newNotifs) ? newNotifs : [newNotifs];\r\n\r\n        setNotifications(prev => {\r\n            const filtered = toAdd.filter(notif => {\r\n                // Deduplicate by ID\r\n                const idExists = prev.some(p => p.id === notif.id);\r\n                if (idExists) return false;\r\n\r\n                // Deduplicate by Content (avoid spamming similar insights/alerts in a short window)\r\n                const similarExists = prev.some(p =>\r\n                    p.type === notif.type &&\r\n                    p.message === notif.message &&\r\n                    !p.read &&\r\n                    (new Date().getTime() - new Date(p.timestamp).getTime() < 1000 * 60 * 60 * 24) // 24h window\r\n                );\r\n                return !similarExists;\r\n            });\r\n\r\n            if (filtered.length === 0) return prev;\r\n\r\n            // Merge, Sort by timestamp descending, and Prune to top 100\r\n            const combined = [...filtered, ...prev].sort((a, b) =>\r\n                new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()\r\n            );\r\n\r\n            return combined.slice(0, 100);\r\n        });\r\n\r\n        // Schedule Native Local Notification if on Native Platform\r\n        if (Capacitor.isNativePlatform()) {\r\n            toAdd.forEach(notif => {\r\n                // Only send native notifications for higher priority items or specific types\r\n                if (notif.priority === 'high' || notif.type === 'reminder' || notif.type === 'alert' || notif.type === 'achievement') {\r\n                    LocalNotifications.schedule({\r\n                        notifications: [{\r\n                            id: Math.floor(Math.random() * 1000000), // Random ID for native notification\r\n                            title: notif.title,\r\n                            body: notif.message,\r\n                            largeIcon: 'res://drawable/splash',\r\n                            smallIcon: 'res://drawable/splash',\r\n                            schedule: { at: new Date(Date.now() + 1000) }, // Schedule almost immediately\r\n                            extra: {\r\n                                notificationId: notif.id,\r\n                                achievementId: notif.achievementId,\r\n                                type: notif.type,\r\n                                category: notif.category,\r\n                                view: notif.type === 'achievement' ? undefined : (\r\n                                    notif.category === 'reminders' ? 'liability' :\r\n                                        notif.category === 'transactions' ? 'transactions' : 'dashboard'\r\n                                )\r\n                            }\r\n                        }]\r\n                    }).catch(err => console.error('Failed to schedule local notification:', err));\r\n                }\r\n            });\r\n        }\r\n    }, []);\r\n\r\n    const checkSmartDues = React.useCallback(() => {\r\n        const today = new Date();\r\n        today.setHours(0, 0, 0, 0);\r\n\r\n        // 1. Calculate Liquid Balance (Bank/Cash - Goal/Emergency Reservations)\r\n        const totalLiquidBank = accounts.reduce((sum, acc) => sum + (acc.type === 'bank' || acc.type === 'cash' ? acc.balance : 0), 0);\r\n        const totalReserved = goals.reduce((sum, g) => sum + g.currentAmount, 0) + emergencyFundAmount;\r\n        const availableLiquidity = Math.max(0, totalLiquidBank - totalReserved);\r\n\r\n        const upcomingDues: { name: string, amount: number, dueDate: Date, type: string }[] = [];\r\n\r\n        // 2. Scan Liabilities (Loans)\r\n        liabilities.forEach(l => {\r\n            const start = new Date(l.startDate);\r\n            // Simple assumption: due on the same day as startDate every month\r\n            const dueThisMonth = new Date(today.getFullYear(), today.getMonth(), start.getDate());\r\n\r\n            // If it's already passed this month, look at next month\r\n            if (dueThisMonth < today) {\r\n                dueThisMonth.setMonth(dueThisMonth.getMonth() + 1);\r\n            }\r\n\r\n            const diffDays = Math.ceil((dueThisMonth.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n            if (diffDays <= 7) {\r\n                upcomingDues.push({ name: l.name, amount: l.emiAmount, dueDate: dueThisMonth, type: 'EMI' });\r\n            }\r\n        });\r\n\r\n        // 3. Scan Recurring Transactions (Subscriptions/Bills)\r\n        recurringTransactions.forEach(r => {\r\n            if (r.type === 'expense') {\r\n                const start = new Date(r.startDate);\r\n                let nextDue: Date;\r\n\r\n                if (r.frequency === 'monthly') {\r\n                    nextDue = new Date(today.getFullYear(), today.getMonth(), start.getDate());\r\n                    if (nextDue < today) nextDue.setMonth(nextDue.getMonth() + 1);\r\n                } else if (r.frequency === 'weekly') {\r\n                    const daysUntilDue = (start.getDay() - today.getDay() + 7) % 7;\r\n                    nextDue = new Date(today.getTime() + daysUntilDue * 24 * 60 * 60 * 1000);\r\n                    if (nextDue < today) nextDue.setDate(nextDue.getDate() + 7);\r\n                } else if (r.frequency === 'custom') {\r\n                    // Custom Cycle Logic (e.g. 28 days)\r\n                    const interval = r.customIntervalDays || 28; // Default to 28 if not set\r\n                    const timeDiff = today.getTime() - start.getTime();\r\n                    const daysSinceStart = Math.floor(timeDiff / (1000 * 60 * 60 * 24));\r\n\r\n                    // Calculate how many cycles have passed\r\n                    // const cyclesPassed = Math.floor(daysSinceStart / interval);\r\n                    const daysIntoCurrentCycle = daysSinceStart % interval;\r\n\r\n                    // Next due is end of current cycle\r\n                    const daysRemaining = interval - daysIntoCurrentCycle;\r\n                    nextDue = new Date(today.getTime() + (daysRemaining * 24 * 60 * 60 * 1000));\r\n\r\n                    // Special case: If due today or passed but assumed future for strict calculation\r\n                    if (daysRemaining <= 0) {\r\n                        nextDue = new Date(today.getTime() + (interval * 24 * 60 * 60 * 1000));\r\n                    }\r\n                } else {\r\n                    // Simplification for daily/yearly\r\n                    return;\r\n                }\r\n\r\n                const diffDays = Math.ceil((nextDue.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n                // Logic: Show regular bills 7 days prior, but Custom/Recharges specifically 2 days prior as requested\r\n                const alertWindow = r.frequency === 'custom' ? 2 : 7;\r\n\r\n                if (diffDays <= alertWindow && diffDays >= 0) {\r\n                    upcomingDues.push({ name: r.description || 'Subscription', amount: r.amount, dueDate: nextDue, type: r.frequency === 'custom' ? 'Recharge' : 'Bill' });\r\n                }\r\n            }\r\n        });\r\n\r\n        // 4. Generate Smart Alerts\r\n        upcomingDues.forEach(due => {\r\n            const isLiquidityBreach = availableLiquidity < due.amount;\r\n            const daysLeft = Math.ceil((due.dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n            if (isLiquidityBreach && daysLeft <= 3) {\r\n                // CRITICAL SMART ALERT\r\n                const alert: Notification = {\r\n                    id: `smart_breach_${due.name}_${due.dueDate.toISOString().split('T')[0]}`,\r\n                    type: 'alert',\r\n                    priority: 'high',\r\n                    category: 'reminders',\r\n                    title: 'Liquid Stability Warning',\r\n                    message: `Critical: Your '${due.name}' due on ${due.dueDate.toLocaleDateString()} (${due.amount}) exceeds current liquid cash (${availableLiquidity}). Clear assets or increase bank balance immediately.`,\r\n                    timestamp: new Date(),\r\n                    read: false\r\n                };\r\n                addNotifications(alert);\r\n                toast.error(alert.title, { description: alert.message, duration: 10000 });\r\n            } else if (daysLeft <= 1) {\r\n                // Standard Reminder\r\n                const reminder: Notification = {\r\n                    id: `reminder_${due.name}_${due.dueDate.toISOString().split('T')[0]}`,\r\n                    type: 'reminder',\r\n                    priority: 'medium',\r\n                    category: 'reminders',\r\n                    title: `${due.type} Due Soon`,\r\n                    message: `Reminder: '${due.name}' payment of ${due.amount} is due tomorrow (${due.dueDate.toLocaleDateString()}).`,\r\n                    timestamp: new Date(),\r\n                    read: false\r\n                };\r\n                addNotifications(reminder);\r\n                toast.info(reminder.title, { description: reminder.message });\r\n            }\r\n        });\r\n    }, [accounts, goals, emergencyFundAmount, liabilities, recurringTransactions, addNotifications]);\r\n\r\n    // Check for new achievements\r\n    const checkForAchievements = React.useCallback(() => {\r\n        if (authStatus !== 'authenticated') return;\r\n\r\n        const totalTransactions = expenses.length + incomes.length + debts.length;\r\n        const settledDebts = debts.filter((d: Debt) => d.status === \"settled\").length;\r\n        const completedGoals = goals.filter((g: Goal) => g.currentAmount >= g.targetAmount).length;\r\n        const totalIncome = incomes.reduce((sum: number, i: Income) => sum + i.amount, 0);\r\n        const totalExpenses = expenses.reduce((sum: number, e: Expense) => sum + e.amount, 0);\r\n        const savingsRate = totalIncome > 0 ? (totalIncome - totalExpenses) / totalIncome : 0;\r\n        const monthlySpendingRatio = totalIncome > 0 ? totalExpenses / totalIncome : 0;\r\n\r\n        const achievementData = {\r\n            totalTransactions,\r\n            totalGoals: goals.length,\r\n            completedGoals,\r\n            totalDebts: debts.length,\r\n            settledDebts,\r\n            savingsRate,\r\n            monthlySpendingRatio,\r\n            notificationsEnabled: settings.notificationsEnabled,\r\n            themeChanged: settings.theme !== \"system\",\r\n            aiInteractions: 0,\r\n            currentStreak: totalTransactions > 0 ? Math.min(totalTransactions, 3) : 0,\r\n            dailyLogin: true,\r\n            profileComplete: settings.name !== '' && settings.photoURL !== '',\r\n            totalAccounts: accounts.length,\r\n        };\r\n\r\n        const newAchievements = checkAchievements(achievementData, settings.unlockedAchievements);\r\n\r\n        if (newAchievements.length > 0) {\r\n            newAchievements.forEach((achievementId) => {\r\n                const achievement = getAchievement(achievementId);\r\n                if (achievement) {\r\n                    // Create notification\r\n                    const notification: Notification = {\r\n                        id: `notif_${achievementId}`,\r\n                        type: 'achievement',\r\n                        priority: 'low',\r\n                        category: 'achievements',\r\n                        title: 'Achievement Unlocked!',\r\n                        message: `${achievement.icon} ${achievement.name}`,\r\n                        timestamp: new Date(),\r\n                        read: false,\r\n                        achievementId: achievementId\r\n                    };\r\n                    addNotifications(notification);\r\n\r\n                    toast.success(\r\n                        `Achievement Unlocked: ${achievement.icon} ${achievement.name}!`,\r\n                        { duration: 5000 }\r\n                    );\r\n                }\r\n            });\r\n\r\n            // Update settings without triggering a full re-render loop - handled by separate updateSettings call\r\n            // We use a specific simpler update here to avoid circular dependency in API calling if possible,\r\n            // but updateSettings is safe enough.\r\n            updateSettings({\r\n                unlockedAchievements: [...settings.unlockedAchievements, ...newAchievements],\r\n            });\r\n        }\r\n\r\n        // Check for Guruji Insights (Spike detection)\r\n        // Limit to once per session or just check on significant changes\r\n        // For now, we'll check on expense changes and deduplicate by content roughly (or just rely on the user clearing them)\r\n        // A simple refinement: check if we already have a recent unread insight about the same thing?\r\n        // For MVP, just generating them is fine, but let's avoid duplicates in the same batch.\r\n\r\n        const insightMessages = generateGurujiInsights({ expenses, goals, userName: settings.name || 'Friend' });\r\n\r\n        if (insightMessages.length > 0) {\r\n            const newInsightNotifs: Notification[] = [];\r\n\r\n            insightMessages.forEach(msg => {\r\n                const notif = createInsightNotification(msg);\r\n                notif.priority = 'low';\r\n                notif.category = 'insights';\r\n                newInsightNotifs.push(notif);\r\n                toast(notif.title, { description: notif.message, icon: '' });\r\n            });\r\n\r\n            if (newInsightNotifs.length > 0) {\r\n                addNotifications(newInsightNotifs);\r\n            }\r\n        }\r\n\r\n        checkSmartDues();\r\n    }, [authStatus, expenses, incomes, debts, goals, accounts, settings, addNotifications, updateSettings, checkSmartDues]);\r\n\r\n    useEffect(() => {\r\n        if (authStatus !== 'authenticated') return;\r\n        checkForAchievements();\r\n    }, [\r\n        authStatus,\r\n        checkForAchievements,\r\n        expenses,\r\n        incomes,\r\n        debts,\r\n        goals,\r\n        accounts,\r\n        settings,\r\n        updateSettings,\r\n        emergencyFundAmount,\r\n        liabilities,\r\n        recurringTransactions\r\n    ]);\r\n\r\n    // Load from multiple sources on mount\r\n    useEffect(() => {\r\n        loadInitialData();\r\n    }, [loadInitialData]);\r\n\r\n    // Sync state changes to localStorage\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings)), [settings]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.EXPENSES, JSON.stringify(expenses)), [expenses]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.INCOMES, JSON.stringify(incomes)), [incomes]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.DEBTS, JSON.stringify(debts)), [debts]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.GOALS, JSON.stringify(goals)), [goals]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.ACCOUNTS, JSON.stringify(accounts)), [accounts]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.INVESTMENTS, JSON.stringify(investments)), [investments]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.LIABILITIES, JSON.stringify(liabilities)), [liabilities]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.RECURRING, JSON.stringify(recurringTransactions)), [recurringTransactions]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.NOTIFICATIONS, JSON.stringify(notifications)), [notifications]);\r\n    useEffect(() => localStorage.setItem(STORAGE_KEYS.EMERGENCY_FUND, JSON.stringify(emergencyFundAmount)), [emergencyFundAmount]);\r\n\r\n\r\n    // ------------------------------------------------------------------\r\n    // Security & Inactivity\r\n    // ------------------------------------------------------------------\r\n    useEffect(() => {\r\n        if (authStatus !== 'authenticated') return;\r\n\r\n        let timeoutId: any;\r\n        const INACTIVITY_LIMIT = 10 * 60 * 1000; // 10 minutes for beta/safety\r\n\r\n        const resetTimer = () => {\r\n            clearTimeout(timeoutId);\r\n            timeoutId = setTimeout(() => {\r\n                logout();\r\n                toast.info(\"Session locked\", { description: \"You were logged out due to inactivity.\" });\r\n            }, INACTIVITY_LIMIT);\r\n        };\r\n\r\n        const activityEvents = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];\r\n        activityEvents.forEach(event => window.addEventListener(event, resetTimer));\r\n\r\n        // Background handling\r\n        const handleVisibilityChange = () => {\r\n            if (document.visibilityState === 'hidden' && authStatus === 'authenticated') {\r\n                logout();\r\n            }\r\n        };\r\n        document.addEventListener('visibilitychange', handleVisibilityChange);\r\n\r\n        // Capacitor App State handling\r\n        let appStateListener: any;\r\n        if (Capacitor.isNativePlatform()) {\r\n            App.addListener('appStateChange', ({ isActive }) => {\r\n                if (!isActive && authStatus === 'authenticated') {\r\n                    logout();\r\n                }\r\n            }).then(l => appStateListener = l);\r\n        }\r\n\r\n        resetTimer();\r\n\r\n        return () => {\r\n            clearTimeout(timeoutId);\r\n            activityEvents.forEach(event => window.removeEventListener(event, resetTimer));\r\n            document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n            if (appStateListener) appStateListener.remove();\r\n        };\r\n    }, [authStatus, logout]);\r\n\r\n    const loadInitialData = React.useCallback(async () => {\r\n        setIsLoading(true);\r\n\r\n        // 1. Try to load from LocalStorage first (Fast load)\r\n        try {\r\n            const storedSettings = localStorage.getItem(STORAGE_KEYS.SETTINGS);\r\n            if (storedSettings) {\r\n                const parsed = JSON.parse(storedSettings);\r\n                setSettings(parsed);\r\n                applyTheme(parsed.theme);\r\n            }\r\n\r\n            const storedExpenses = localStorage.getItem(STORAGE_KEYS.EXPENSES);\r\n            if (storedExpenses) setExpenses(JSON.parse(storedExpenses));\r\n\r\n            const storedIncomes = localStorage.getItem(STORAGE_KEYS.INCOMES);\r\n            if (storedIncomes) setIncomes(JSON.parse(storedIncomes));\r\n\r\n            const storedDebts = localStorage.getItem(STORAGE_KEYS.DEBTS);\r\n            if (storedDebts) setDebts(JSON.parse(storedDebts));\r\n\r\n            const storedGoals = localStorage.getItem(STORAGE_KEYS.GOALS);\r\n            if (storedGoals) setGoals(JSON.parse(storedGoals));\r\n\r\n            const storedAccounts = localStorage.getItem(STORAGE_KEYS.ACCOUNTS);\r\n            if (storedAccounts) setAccounts(JSON.parse(storedAccounts));\r\n\r\n            const storedInvestments = localStorage.getItem(STORAGE_KEYS.INVESTMENTS);\r\n            if (storedInvestments) setInvestments(JSON.parse(storedInvestments));\r\n\r\n            const storedLiabilities = localStorage.getItem(STORAGE_KEYS.LIABILITIES);\r\n            if (storedLiabilities) setLiabilities(JSON.parse(storedLiabilities));\r\n\r\n            const storedNotifications = localStorage.getItem(STORAGE_KEYS.NOTIFICATIONS);\r\n            if (storedNotifications) {\r\n                const parsed: Notification[] = JSON.parse(storedNotifications);\r\n                // Deduplicate and Prune on load\r\n                const unique = parsed.filter((v, i, a) => a.findIndex(t => t.id === v.id || (t.message === v.message && t.type === v.type)) === i);\r\n                setNotifications(unique.slice(0, 100));\r\n            }\r\n\r\n            const storedEmergencyFund = localStorage.getItem(STORAGE_KEYS.EMERGENCY_FUND);\r\n            if (storedEmergencyFund) setEmergencyFundAmount(JSON.parse(storedEmergencyFund));\r\n\r\n            const storedRecurring = localStorage.getItem(STORAGE_KEYS.RECURRING);\r\n            if (storedRecurring) setRecurringTransactions(JSON.parse(storedRecurring));\r\n\r\n            const storedRememberedMobile = localStorage.getItem(STORAGE_KEYS.REMEMBERED_MOBILE);\r\n            if (storedRememberedMobile) {\r\n                setRememberedMobile(storedRememberedMobile);\r\n                setPendingMobile(storedRememberedMobile);\r\n                setIsRememberedUser(true);\r\n            }\r\n\r\n            const storedDeletion = localStorage.getItem(STORAGE_KEYS.DELETION_SCHEDULE);\r\n            if (storedDeletion) {\r\n                const deletionTime = new Date(storedDeletion).getTime();\r\n                const now = new Date().getTime();\r\n\r\n                if (now >= deletionTime) {\r\n                    // 30 days have passed. Execute total purge.\r\n                    purgeAllData();\r\n                    console.warn(\"Account purge executed based on schedule.\");\r\n                } else {\r\n                    setDeletionDate(storedDeletion);\r\n                }\r\n            }\r\n\r\n        } catch (e) {\r\n            console.error(\"Error loading specific local data:\", e);\r\n        }\r\n\r\n        // 2. Fetch from API (Sync)\r\n        await fetchFromApi();\r\n\r\n        // 3. Subscription Migration (One-time or periodic scan)\r\n        const hasMigrationRun = localStorage.getItem('finhub_subscription_migration_v3');\r\n        if (!hasMigrationRun && userId) {\r\n            runCategorizationMigration();\r\n            localStorage.setItem('finhub_subscription_migration_v3', 'true');\r\n        }\r\n\r\n        setIsLoading(false);\r\n    }, [userId, fetchFromApi, runCategorizationMigration, applyTheme]);\r\n    const runCategorizationMigration = React.useCallback(() => {\r\n        setExpenses(prevExpenses => {\r\n            let updatedCount = 0;\r\n            const nextExpenses = prevExpenses.map(e => {\r\n                const genericCategories = ['other', 'bills & utilities', 'entertainment', 'shopping', '', undefined];\r\n                const suggestion = autoCategorize(e.description);\r\n\r\n                if (suggestion && suggestion.category === 'Subscription') {\r\n                    const shouldUpdateCategory = genericCategories.includes(e.category?.toLowerCase()) || !e.category;\r\n                    const shouldUpdateRecurring = !e.isRecurring;\r\n\r\n                    if (shouldUpdateCategory || shouldUpdateRecurring) {\r\n                        updatedCount++;\r\n                        return {\r\n                            ...e,\r\n                            category: 'Subscription',\r\n                            isRecurring: true\r\n                        };\r\n                    }\r\n                }\r\n                return e;\r\n            });\r\n\r\n            if (updatedCount > 0) {\r\n                toast.info(`Intelligence protocol: Identified and moved ${updatedCount} transactions to Subscriptions.`);\r\n\r\n                // One-time auto-creation of RecurringTransaction templates for found subscriptions\r\n                // We do this by finding the most recent expense for each unique subscription description\r\n                const subExpenses = nextExpenses.filter(e => e.category === 'Subscription');\r\n                const uniqueSubs = new Map<string, Expense>();\r\n\r\n                subExpenses.forEach(e => {\r\n                    const name = e.description.toLowerCase().trim();\r\n                    if (!uniqueSubs.has(name) || new Date(e.date) > new Date(uniqueSubs.get(name)!.date)) {\r\n                        uniqueSubs.set(name, e);\r\n                    }\r\n                });\r\n\r\n                // Create recurring entries for those that don't exist yet\r\n                uniqueSubs.forEach((exp, name) => {\r\n                    const alreadyTracked = recurringTransactions.some(rt =>\r\n                        rt.description?.toLowerCase().includes(name) ||\r\n                        name.includes(rt.description?.toLowerCase() || '')\r\n                    );\r\n\r\n                    if (!alreadyTracked) {\r\n                        // Create it (using a timeout to avoid triggering multiple state updates synchronously)\r\n                        setTimeout(() => {\r\n                            createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: exp.description,\r\n                                amount: exp.amount,\r\n                                category: 'Subscription',\r\n                                accountId: exp.accountId,\r\n                                frequency: 'monthly',\r\n                                startDate: exp.date,\r\n                                tags: ['auto-migrated']\r\n                            });\r\n                        }, 100);\r\n                    }\r\n                });\r\n            }\r\n            return nextExpenses;\r\n        });\r\n    }, [recurringTransactions, createRecurringTransaction]);\r\n\r\n    const fetchFromApi = React.useCallback(async () => {\r\n        try {\r\n            // Auto-process recurring\r\n            try {\r\n                await api.processRecurring(userId);\r\n            } catch (e) { console.error(\"Skip recurring process\", e) }\r\n\r\n            // Fetch all concurrently\r\n            const [\r\n                settingsRes,\r\n                accountsRes,\r\n                expensesRes,\r\n                incomesRes,\r\n                debtsRes,\r\n                goalsRes,\r\n                liabilitiesRes,\r\n                investmentsRes,\r\n                recurringRes\r\n            ] = await Promise.all([\r\n                api.getSettings(userId).catch(() => ({ success: false, settings: undefined })),\r\n                api.getAccounts(userId).catch(() => ({ success: false, accounts: [] })),\r\n                api.getExpenses(userId).catch(() => ({ success: false, expenses: [] })),\r\n                api.getIncomes(userId).catch(() => ({ success: false, incomes: [] })),\r\n                api.getDebts(userId).catch(() => ({ success: false, debts: [] })),\r\n                api.getGoals(userId).catch(() => ({ success: false, goals: [] })),\r\n                api.getLiabilities(userId).catch(() => ({ success: false, liabilities: [] })),\r\n                api.getInvestments(userId).catch(() => ({ success: false, investments: [] })),\r\n                api.getRecurring(userId).catch(() => ({ success: false, recurring: [] })),\r\n            ]);\r\n\r\n            setIsOffline(false);\r\n            setApiStatus('online');\r\n\r\n            if (settingsRes.success && settingsRes.settings) {\r\n                // Merge server settings with local settings to preserve local-only fields like aiProvider and apiKeys\r\n                setSettings(prev => ({\r\n                    ...prev,\r\n                    ...settingsRes.settings,\r\n                    // Specifically preserve these if missing from server response\r\n                    aiProvider: settingsRes.settings.aiProvider || prev.aiProvider,\r\n                    apiKeys: { ...prev.apiKeys, ...settingsRes.settings.apiKeys }\r\n                }));\r\n                applyTheme(settingsRes.settings.theme);\r\n            }\r\n            if (accountsRes.success) setAccounts(accountsRes.accounts || []);\r\n            if (expensesRes.success) setExpenses(expensesRes.expenses || []);\r\n            if (incomesRes.success) setIncomes(incomesRes.incomes || []);\r\n            if (debtsRes.success) setDebts(debtsRes.debts || []);\r\n            if (goalsRes.success) setGoals(goalsRes.goals || []);\r\n            if (liabilitiesRes.success) setLiabilities(liabilitiesRes.liabilities || []);\r\n            if (investmentsRes.success) setInvestments(investmentsRes.investments || []);\r\n            if (recurringRes.success) setRecurringTransactions(recurringRes.recurring || []);\r\n\r\n            toast.success(\"Sync complete\");\r\n\r\n        } catch (error) {\r\n            console.error(\"API Sync failed, using local data\", error);\r\n            setIsOffline(true);\r\n            setApiStatus('offline');\r\n            // toast.error(\"Sync failed - using offline mode\");\r\n        }\r\n    }, [userId, applyTheme]);\r\n\r\n    const refreshData = async () => {\r\n        setIsRefreshing(true);\r\n        await fetchFromApi();\r\n        setIsRefreshing(false);\r\n    };\r\n\r\n    const applyTheme = React.useCallback((theme: \"light\" | \"dark\" | \"system\") => {\r\n        if (theme === \"system\") {\r\n            const prefersDark = window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\r\n            document.documentElement.classList.toggle(\"dark\", prefersDark);\r\n        } else {\r\n            document.documentElement.classList.toggle(\"dark\", theme === \"dark\");\r\n        }\r\n    }, []);\r\n\r\n    // ------------------------------------------------------------------\r\n    // Auth Actions\r\n    // ------------------------------------------------------------------\r\n\r\n    const checkIdentity = async (mobile: string) => {\r\n        setPendingMobile(mobile);\r\n        // Simulate API check\r\n        const isExistingUser = DEMO_USERS.some(u => u.mobile === mobile) ||\r\n            localStorage.getItem(`finhub_user_${mobile}`) !== null;\r\n\r\n        setIsAwaitingPin(true);\r\n        return isExistingUser;\r\n    };\r\n\r\n    const login = async (pin: string, rememberMe: boolean = false) => {\r\n        // Authenticating state triggers LoadingSprite\r\n        setAuthMessage({ message: \"Validating PIN\", subMessage: \"Verifying secure node access...\" });\r\n        setAuthStatus('authenticating');\r\n\r\n        // Artificial delay for Loading Sprite showcase\r\n        await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n        const demoUser = DEMO_USERS.find(u => u.mobile === pendingMobile && u.pin === pin);\r\n\r\n        let authenticatedUser: AuthUser | null = null;\r\n\r\n        if (demoUser) {\r\n            authenticatedUser = {\r\n                id: demoUser.userId,\r\n                mobile: demoUser.mobile,\r\n                name: demoUser.name\r\n            };\r\n        } else {\r\n            const storedUser = localStorage.getItem(`finhub_user_${pendingMobile}`);\r\n            if (storedUser) {\r\n                const parsed = JSON.parse(storedUser);\r\n                if (parsed.pin === pin) {\r\n                    authenticatedUser = {\r\n                        id: parsed.userId,\r\n                        mobile: parsed.mobile,\r\n                        name: parsed.name\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        if (authenticatedUser) {\r\n            setCurrentUser(authenticatedUser);\r\n            localStorage.setItem(STORAGE_KEYS.AUTH, JSON.stringify(authenticatedUser));\r\n            setAuthMessage({ message: \"Handshake Success\", subMessage: \"Synchronizing decrypted ledger...\" });\r\n            setAuthStatus('authenticated');\r\n            setIsAwaitingPin(false);\r\n\r\n            // Handle deletion cancellation on login\r\n            if (deletionDate) {\r\n                await cancelAccountDeletion();\r\n                toast.success('Your account deletion request has been canceled. Welcome back!');\r\n            }\r\n\r\n            if (rememberMe) {\r\n                localStorage.setItem(STORAGE_KEYS.REMEMBERED_MOBILE, pendingMobile);\r\n                setRememberedMobile(pendingMobile);\r\n                setIsRememberedUser(true);\r\n            } else {\r\n                // If they explicitly log in without remember me, we might want to clear it \r\n                // but the requirement says \"Smart Prompt\" if they didn't check it.\r\n                // So we leave existing remembered mobile but don't update it to THIS session if different.\r\n            }\r\n\r\n            return true;\r\n        } else {\r\n            setAuthMessage(undefined);\r\n            setAuthStatus('guest'); // Reset to guest on failure\r\n            return false;\r\n        }\r\n    };\r\n\r\n    const sendOtp = async (mobile: string) => {\r\n        setPendingMobile(mobile);\r\n        // Simulate OTP generation\r\n        const mockOtp = Math.floor(1000 + Math.random() * 9000).toString();\r\n        setGeneratedOtp(mockOtp);\r\n        console.log(`[AUTH-DEBUG] Mock OTP for ${mobile}: ${mockOtp}`);\r\n\r\n        // Show simulated toast\r\n        toast.info(\"Verification code sent\", {\r\n            description: `Dev Mode: Use ${mockOtp} (Simulated SMS)`\r\n        });\r\n\r\n        return true;\r\n    };\r\n\r\n    const verifyOtp = async (_mobile: string, otp: string) => {\r\n        // Skip check in testing phase as requested, but we'll show logic\r\n        if (otp === \"0000\" || otp === generatedOtp) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const resetPin = async (mobile: string, newPin: string) => {\r\n        const storedUser = localStorage.getItem(`finhub_user_${mobile}`);\r\n        if (storedUser) {\r\n            const parsed = JSON.parse(storedUser);\r\n            parsed.pin = newPin;\r\n            localStorage.setItem(`finhub_user_${mobile}`, JSON.stringify(parsed));\r\n            toast.success(\"PIN reset successfully\");\r\n            return true;\r\n        }\r\n        // Also check demo users (can't really reset them permanently in localStorage easily without shadowing)\r\n        const demoUserIndex = DEMO_USERS.findIndex(u => u.mobile === mobile);\r\n        if (demoUserIndex !== -1) {\r\n            // Shadow demo user in localStorage\r\n            const shadowedUser = {\r\n                ...DEMO_USERS[demoUserIndex],\r\n                pin: newPin\r\n            };\r\n            localStorage.setItem(`finhub_user_${mobile}`, JSON.stringify(shadowedUser));\r\n            toast.success(\"Demo user PIN updated locally\");\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    const signup = async (mobile: string, pin: string, name: string, rememberMe: boolean = false) => {\r\n        setAuthMessage({ message: \"Creating Node\", subMessage: \"Initializing secure identity protocols...\" });\r\n        setAuthStatus('authenticating');\r\n        await new Promise(resolve => setTimeout(resolve, 2000));\r\n\r\n        const newUser: AuthUser & { pin: string } = {\r\n            id: `user_${Date.now()}`,\r\n            mobile,\r\n            name,\r\n            pin\r\n        };\r\n\r\n        localStorage.setItem(`finhub_user_${mobile}`, JSON.stringify(newUser));\r\n        const authUser: AuthUser = { id: newUser.id, mobile: newUser.mobile, name: newUser.name };\r\n        setCurrentUser(authUser);\r\n        localStorage.setItem(STORAGE_KEYS.AUTH, JSON.stringify(authUser));\r\n        setAuthMessage({ message: \"Handshake Success\", subMessage: \"Synchronizing decrypted ledger...\" });\r\n        setAuthStatus('authenticated');\r\n        setIsAwaitingPin(false);\r\n\r\n        if (rememberMe) {\r\n            localStorage.setItem(STORAGE_KEYS.REMEMBERED_MOBILE, mobile);\r\n            setRememberedMobile(mobile);\r\n            setIsRememberedUser(true);\r\n            return true;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    const logout = React.useCallback(() => {\r\n        setAuthStatus('guest');\r\n        setCurrentUser(null);\r\n        setGeneratedOtp(null);\r\n        localStorage.removeItem(STORAGE_KEYS.AUTH);\r\n        // If not remembered, clear the pending mobile so it asks for username next time\r\n        if (!isRememberedUser) {\r\n            setPendingMobile('');\r\n        }\r\n    }, [isRememberedUser]);\r\n    const clearPendingSession = () => {\r\n        setAuthStatus('guest');\r\n        setCurrentUser(null);\r\n        setPendingMobile('');\r\n        setGeneratedOtp(null);\r\n        localStorage.removeItem(STORAGE_KEYS.AUTH);\r\n        localStorage.removeItem(STORAGE_KEYS.REMEMBERED_MOBILE);\r\n        setRememberedMobile('');\r\n        setIsRememberedUser(false);\r\n    };\r\n\r\n    const scheduleAccountDeletion = async () => {\r\n        const date = new Date();\r\n        date.setDate(date.getDate() + 30);\r\n        const dateString = date.toISOString();\r\n\r\n        setDeletionDate(dateString);\r\n        localStorage.setItem(STORAGE_KEYS.DELETION_SCHEDULE, dateString);\r\n\r\n        toast.warning('Account scheduled for deletion in 30 days.');\r\n        logout();\r\n    };\r\n\r\n    const cancelAccountDeletion = async () => {\r\n        setDeletionDate(null);\r\n        localStorage.removeItem(STORAGE_KEYS.DELETION_SCHEDULE);\r\n    };\r\n\r\n    const purgeAllData = () => {\r\n        // Clear all known storage keys\r\n        Object.values(STORAGE_KEYS).forEach(key => {\r\n            localStorage.removeItem(key);\r\n        });\r\n\r\n        // Reset state\r\n        setExpenses([]);\r\n        setIncomes([]);\r\n        setDebts([]);\r\n        setGoals([]);\r\n        setAccounts([]);\r\n        setInvestments([]);\r\n        setLiabilities([]);\r\n        setRecurringTransactions([]);\r\n        setNotifications([]);\r\n        setEmergencyFundAmount(0);\r\n        setDeletionDate(null);\r\n        setAuthStatus('guest');\r\n        setCurrentUser(null);\r\n\r\n        toast.info('Session purged successfully.');\r\n    };\r\n\r\n    // Auto-login from storage - Restore session context but require PIN\r\n    useEffect(() => {\r\n        const storedAuth = localStorage.getItem(STORAGE_KEYS.AUTH);\r\n        if (storedAuth) {\r\n            try {\r\n                const user = JSON.parse(storedAuth);\r\n                if (user && user.mobile) {\r\n                    setPendingMobile(user.mobile);\r\n                    // We stay as 'guest' so App.tsx shows LoginScreen\r\n                    // LoginScreen will detect pendingMobile and show PIN verify phase\r\n                    setAuthStatus('guest');\r\n                }\r\n            } catch (e) {\r\n                console.error(\"Failed to parse stored auth\", e);\r\n                localStorage.removeItem(STORAGE_KEYS.AUTH);\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    // ------------------------------------------------------------------\r\n    // Actions\r\n    // ------------------------------------------------------------------\r\n\r\n    const updateSettings = async (updates: Partial<UserSettings>) => {\r\n        // Optimistic update\r\n        const newSettings = { ...settings, ...updates };\r\n        setSettings(newSettings);\r\n        if (updates.theme) applyTheme(updates.theme);\r\n\r\n        try {\r\n            const response = await api.updateSettings(userId, updates);\r\n            if (response.success) {\r\n                // Merge response with existing state to avoid losing local-only fields\r\n                setSettings(prev => ({\r\n                    ...prev,\r\n                    ...response.settings,\r\n                    aiProvider: response.settings.aiProvider || prev.aiProvider,\r\n                    apiKeys: { ...prev.apiKeys, ...response.settings.apiKeys }\r\n                }));\r\n            } else {\r\n                throw new Error(response.error);\r\n            }\r\n        } catch (error) {\r\n            console.error(\"Failed to sync settings\", error);\r\n            toast.error(\"Settings saved locally only\");\r\n        }\r\n    };\r\n\r\n    // --- Recurring ---\r\n    const updateRecurringTransaction = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateRecurring(userId, id, data);\r\n            if (response.success) {\r\n                const updatedRec = response.recurring as RecurringTransaction;\r\n                setRecurringTransactions(prev => prev.map(r => r.id === id ? updatedRec : r));\r\n                toast.success('Recurring transaction updated');\r\n\r\n                // Auto-Backfill Logic (Standardized Refactor)\r\n                if (updatedRec.startDate) {\r\n                    console.log(\"[Backfill Debug Update] Analysis starting for:\", updatedRec.description || updatedRec.source);\r\n                    toast.info(\"Analyzing transaction history...\");\r\n\r\n                    const localNow = new Date();\r\n                    const nowStr = `${localNow.getFullYear()}-${String(localNow.getMonth() + 1).padStart(2, '0')}-${String(localNow.getDate()).padStart(2, '0')}`;\r\n                    const startStr = updatedRec.startDate.split('T')[0];\r\n\r\n                    console.log(\"[Backfill Debug Update] nowStr:\", nowStr, \"startStr:\", startStr);\r\n\r\n                    if (startStr <= nowStr && updatedRec.type) {\r\n                        const [sY, sM, sD] = startStr.split('-').map(Number);\r\n                        const current = new Date(sY, sM - 1, sD, 12, 0, 0);\r\n                        const dueDates: Date[] = [];\r\n                        let safety = 0;\r\n\r\n                        while (safety < 1200) {\r\n                            const cY = current.getFullYear();\r\n                            const cM = current.getMonth();\r\n                            const cD = current.getDate();\r\n                            const currentStr = `${cY}-${String(cM + 1).padStart(2, '0')}-${String(cD).padStart(2, '0')}`;\r\n                            if (currentStr > nowStr) break;\r\n                            dueDates.push(new Date(current));\r\n\r\n                            switch (updatedRec.frequency) {\r\n                                case 'daily': current.setDate(current.getDate() + 1); break;\r\n                                case 'weekly': current.setDate(current.getDate() + 7); break;\r\n                                case 'monthly': {\r\n                                    const origDay = sD;\r\n                                    current.setMonth(current.getMonth() + 1);\r\n                                    if (current.getDate() < origDay && current.getMonth() === (cM + 2) % 12) {\r\n                                        current.setDate(0);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                case 'yearly': current.setFullYear(current.getFullYear() + 1); break;\r\n                                case 'custom':\r\n                                    current.setDate(current.getDate() + (updatedRec.customIntervalDays || 30));\r\n                                    break;\r\n                                default: current.setMonth(current.getMonth() + 1);\r\n                            }\r\n                            safety++;\r\n                        }\r\n\r\n                        console.log(\"[Backfill Debug Update] Generated\", dueDates.length, \"due dates\");\r\n\r\n                        const recAmount = Number(updatedRec.amount);\r\n                        const recDesc = (updatedRec.description || updatedRec.source || '').toLowerCase().trim();\r\n\r\n                        const missingDates = dueDates.filter(due => {\r\n                            const dStr = `${due.getFullYear()}-${String(due.getMonth() + 1).padStart(2, '0')}-${String(due.getDate()).padStart(2, '0')}`;\r\n\r\n                            const exists = [...expenses, ...incomes].some(tx => {\r\n                                const txDate = (tx.date || '').split('T')[0];\r\n                                const txAmount = Number(tx.amount);\r\n                                const txDesc = (('description' in tx ? tx.description : (tx as any).source) || '').toLowerCase().trim();\r\n\r\n                                const amountMatch = Math.abs(txAmount - recAmount) < 0.01;\r\n                                const descMatch = txDesc.includes(recDesc) || recDesc.includes(txDesc);\r\n\r\n                                // Frequency-aware date matching\r\n                                let dateMatch = txDate === dStr;\r\n                                if (updatedRec.frequency === 'monthly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getDate() - due.getDate());\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear() &&\r\n                                        tDate.getMonth() === due.getMonth() &&\r\n                                        diff <= 7;\r\n                                } else if (updatedRec.frequency === 'weekly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getTime() - due.getTime()) / (1000 * 60 * 60 * 24);\r\n                                    dateMatch = diff <= 3;\r\n                                } else if (updatedRec.frequency === 'yearly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear();\r\n                                }\r\n\r\n                                // Link matching (if previously recorded)\r\n                                const linkMatch = tx.recurringId === updatedRec.id;\r\n\r\n                                return (descMatch || linkMatch) && dateMatch && amountMatch;\r\n                            });\r\n                            return !exists;\r\n                        });\r\n\r\n                        console.log(`[Backfill Debug Update] Total Expected: ${dueDates.length}, Missing: ${missingDates.length}`);\r\n\r\n                        if (missingDates.length > 0) {\r\n                            console.log(\"[Backfill Debug Update] Triggering popup request for\", missingDates.length, \"dates\");\r\n                            setBackfillRequest({\r\n                                count: missingDates.length,\r\n                                dates: missingDates,\r\n                                recurring: updatedRec\r\n                            });\r\n                        } else {\r\n                            console.log(\"[Backfill Debug Update] All expected entries already exist in history.\");\r\n                            toast.success(\"Transaction history is already up to date.\");\r\n                        }\r\n                    } else {\r\n                        console.log(\"[Backfill Debug Update] Skip: start date is in the future or invalid type.\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.error('Error updating recurring transaction:', error);\r\n            setRecurringTransactions(prev => prev.map(r => r.id === id ? { ...r, ...data } : r));\r\n            toast.warning('Updated locally');\r\n        }\r\n    };\r\n\r\n    const createRecurringTransaction = async (data: any) => {\r\n        try {\r\n            console.log(\"[Backfill Debug] createRecurringTransaction called with:\", data);\r\n            const response = await api.createRecurring(userId, data);\r\n            if (response.success) {\r\n                const newRec = response.recurring;\r\n                setRecurringTransactions(prev => [...prev, newRec]);\r\n                toast.success('Recurring transaction created');\r\n\r\n                // Auto-Backfill Logic (Timezone-Safe Refactor)\r\n                if (newRec.startDate) {\r\n                    console.log(\"[Backfill Debug] Analysis starting for:\", newRec.description || newRec.source);\r\n                    toast.info(\"Analyzing transaction history...\");\r\n\r\n                    const localNow = new Date();\r\n                    const nowStr = `${localNow.getFullYear()}-${String(localNow.getMonth() + 1).padStart(2, '0')}-${String(localNow.getDate()).padStart(2, '0')}`;\r\n                    const startStr = newRec.startDate.split('T')[0];\r\n\r\n                    console.log(\"[Backfill Debug] nowStr:\", nowStr, \"startStr:\", startStr);\r\n\r\n                    if (startStr <= nowStr && newRec.type) {\r\n                        const [sY, sM, sD] = startStr.split('-').map(Number);\r\n                        const current = new Date(sY, sM - 1, sD, 12, 0, 0);\r\n                        const dueDates: Date[] = [];\r\n                        let safety = 0;\r\n\r\n                        while (safety < 1200) {\r\n                            const cY = current.getFullYear();\r\n                            const cM = current.getMonth();\r\n                            const cD = current.getDate();\r\n                            const currentStr = `${cY}-${String(cM + 1).padStart(2, '0')}-${String(cD).padStart(2, '0')}`;\r\n                            if (currentStr > nowStr) break;\r\n                            dueDates.push(new Date(current));\r\n\r\n                            switch (newRec.frequency) {\r\n                                case 'daily': current.setDate(current.getDate() + 1); break;\r\n                                case 'weekly': current.setDate(current.getDate() + 7); break;\r\n                                case 'monthly': {\r\n                                    const origDay = sD;\r\n                                    current.setMonth(current.getMonth() + 1);\r\n                                    if (current.getDate() < origDay && current.getMonth() === (cM + 2) % 12) {\r\n                                        current.setDate(0);\r\n                                    }\r\n                                    break;\r\n                                }\r\n                                case 'yearly': current.setFullYear(current.getFullYear() + 1); break;\r\n                                case 'custom':\r\n                                    current.setDate(current.getDate() + (newRec.customIntervalDays || 30));\r\n                                    break;\r\n                                default: current.setMonth(current.getMonth() + 1);\r\n                            }\r\n                            safety++;\r\n                        }\r\n\r\n                        console.log(\"[Backfill Debug] Generated\", dueDates.length, \"due dates\");\r\n\r\n                        const recAmount = Number(newRec.amount);\r\n                        const recDesc = (newRec.description || newRec.source || '').toLowerCase().trim();\r\n\r\n                        const missingDates = dueDates.filter(due => {\r\n                            const dStr = `${due.getFullYear()}-${String(due.getMonth() + 1).padStart(2, '0')}-${String(due.getDate()).padStart(2, '0')}`;\r\n\r\n                            const exists = [...expenses, ...incomes].some(tx => {\r\n                                const txDate = (tx.date || '').split('T')[0];\r\n                                const txAmount = Number(tx.amount);\r\n                                const txDesc = (('description' in tx ? tx.description : (tx as any).source) || '').toLowerCase().trim();\r\n\r\n                                const amountMatch = Math.abs(txAmount - recAmount) < 0.01;\r\n                                const descMatch = txDesc.includes(recDesc) || recDesc.includes(txDesc);\r\n\r\n                                // Frequency-aware date matching\r\n                                let dateMatch = txDate === dStr;\r\n                                if (newRec.frequency === 'monthly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getDate() - due.getDate());\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear() &&\r\n                                        tDate.getMonth() === due.getMonth() &&\r\n                                        diff <= 7;\r\n                                } else if (newRec.frequency === 'weekly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    const diff = Math.abs(tDate.getTime() - due.getTime()) / (1000 * 60 * 60 * 24);\r\n                                    dateMatch = diff <= 3;\r\n                                } else if (newRec.frequency === 'yearly') {\r\n                                    const tDate = new Date(txDate);\r\n                                    dateMatch = tDate.getFullYear() === due.getFullYear();\r\n                                }\r\n\r\n                                // Link matching\r\n                                const linkMatch = tx.recurringId === newRec.id;\r\n\r\n                                return (descMatch || linkMatch) && dateMatch && amountMatch;\r\n                            });\r\n                            return !exists;\r\n                        });\r\n\r\n                        console.log(`[Backfill Debug] Total Expected: ${dueDates.length}, Missing: ${missingDates.length}`);\r\n\r\n                        if (missingDates.length > 0) {\r\n                            console.log(\"[Backfill Debug] Triggering popup request for\", missingDates.length, \"dates\");\r\n                            setBackfillRequest({\r\n                                count: missingDates.length,\r\n                                dates: missingDates,\r\n                                recurring: newRec\r\n                            });\r\n                        } else {\r\n                            console.log(\"[Backfill Debug] All expected entries already exist in history.\");\r\n                            toast.success(\"Transaction history is already up to date.\");\r\n                        }\r\n                    } else {\r\n                        console.log(\"[Backfill Debug] Skip: start date is in the future or invalid type.\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.error('Error creating recurring transaction:', error);\r\n            const temp = { id: `temp_${Date.now()}`, ...data, createdAt: new Date().toISOString() };\r\n            setRecurringTransactions(prev => [...prev, temp]);\r\n            toast.warning('Offline: Created locally');\r\n        }\r\n    };\r\n\r\n    const executeBackfill = async () => {\r\n        if (!backfillRequest) return;\r\n        const { count, dates, recurring: newRec } = backfillRequest;\r\n\r\n        // Clear request immediately to prevent duplicate triggers from UI\r\n        setBackfillRequest(null);\r\n\r\n        const toastId = toast.loading(`Generating ${count} entries...`);\r\n        const createdIncomes: any[] = [];\r\n        const createdExpenses: any[] = [];\r\n        let balanceChange = 0;\r\n        const targetAccount = accounts.find(a => a.id === newRec.accountId);\r\n\r\n        console.log(`[Backfill Execution] Starting batch for: ${newRec.description || newRec.source}`);\r\n\r\n        const goalChanges: Record<string, number> = {};\r\n        const liabilityChanges: Record<string, number> = {};\r\n\r\n        try {\r\n            for (const due of dates) {\r\n                const dateStr = `${due.getFullYear()}-${String(due.getMonth() + 1).padStart(2, '0')}-${String(due.getDate()).padStart(2, '0')}`;\r\n                const txData = {\r\n                    description: newRec.description,\r\n                    source: newRec.source,\r\n                    amount: newRec.amount,\r\n                    category: newRec.category,\r\n                    date: dateStr,\r\n                    tags: [...(newRec.tags || []), 'auto-backfill'],\r\n                    accountId: newRec.accountId,\r\n                    isRecurring: true,\r\n                    recurringId: newRec.id,\r\n                    liabilityId: newRec.liabilityId,\r\n                    investmentId: newRec.investmentId\r\n                };\r\n\r\n                console.log(`[Backfill Execution] Creating entry for ${dateStr}...`);\r\n\r\n                if (newRec.type === 'expense') {\r\n                    const res = await api.createExpense(userId, txData);\r\n                    if (res.success) {\r\n                        createdExpenses.push(res.expense);\r\n                        if (targetAccount) {\r\n                            if (targetAccount.type === 'credit_card') balanceChange += res.expense.amount;\r\n                            else balanceChange -= res.expense.amount;\r\n                        }\r\n\r\n                        if (newRec.goalId) {\r\n                            goalChanges[newRec.goalId] = (goalChanges[newRec.goalId] || 0) + res.expense.amount;\r\n                        }\r\n\r\n                        if (newRec.liabilityId) {\r\n                            liabilityChanges[newRec.liabilityId] = (liabilityChanges[newRec.liabilityId] || 0) + res.expense.amount;\r\n                        }\r\n                    }\r\n                } else {\r\n                    const res = await api.createIncome(userId, txData);\r\n                    if (res.success) {\r\n                        createdIncomes.push(res.income);\r\n                        if (targetAccount) {\r\n                            if (targetAccount.type === 'credit_card') balanceChange -= res.income.amount;\r\n                            else balanceChange += res.income.amount;\r\n                        }\r\n                    }\r\n                }\r\n                // Small delay to prevent rate limiting or UI freezing\r\n                await new Promise(r => setTimeout(r, 30));\r\n            }\r\n\r\n            // State Updates and Sync\r\n            if (createdIncomes.length > 0) setIncomes(prev => [...prev, ...createdIncomes]);\r\n            if (createdExpenses.length > 0) setExpenses(prev => [...prev, ...createdExpenses]);\r\n\r\n            // Batch update Goals\r\n            for (const [gid, change] of Object.entries(goalChanges)) {\r\n                const goal = goals.find(g => g.id === gid);\r\n                if (goal) {\r\n                    const newAmount = goal.currentAmount + change;\r\n                    await api.updateGoal(userId, gid, { currentAmount: newAmount });\r\n                    setGoals(prev => prev.map(g => g.id === gid ? { ...g, currentAmount: newAmount } : g));\r\n                }\r\n            }\r\n\r\n            // Batch update Liabilities\r\n            for (const [lid, change] of Object.entries(liabilityChanges)) {\r\n                const liability = liabilities.find(l => l.id === lid);\r\n                if (liability) {\r\n                    const newOutstanding = Math.max(0, liability.outstanding - change);\r\n                    await api.updateLiability(userId, lid, { outstanding: newOutstanding });\r\n                    setLiabilities(prev => prev.map(l => l.id === lid ? { ...l, outstanding: newOutstanding } : l));\r\n                    console.log(`[Backfill] Corrected Liability ${liability.name} by ${change}`);\r\n                }\r\n            }\r\n\r\n            if (targetAccount && balanceChange !== 0) {\r\n                const newBalance = targetAccount.balance + balanceChange;\r\n                await api.updateAccount(userId, targetAccount.id, { balance: newBalance });\r\n                setAccounts(prev => prev.map(a => a.id === targetAccount.id ? { ...a, balance: newBalance } : a));\r\n            }\r\n\r\n            // Automatic dedupe scrub\r\n            await cleanupDuplicates();\r\n\r\n            toast.dismiss(toastId);\r\n            toast.success(`Success: ${count} entries generated`);\r\n        } catch (error) {\r\n            console.error('[Backfill Execution] Fatal error during batch:', error);\r\n            toast.dismiss(toastId);\r\n            toast.error('Backfill failed. Ledger might be partially updated.');\r\n        }\r\n    };\r\n\r\n    const deleteRecurringTransaction = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteRecurring(userId, id);\r\n            if (response.success) {\r\n                setRecurringTransactions(prev => prev.filter(r => r.id !== id));\r\n                toast.success('Recurring transaction deleted');\r\n            }\r\n        } catch (error) {\r\n            console.error('Error deleting recurring transaction:', error);\r\n            setRecurringTransactions(prev => prev.filter(r => r.id !== id));\r\n            toast.warning('Deleted locally');\r\n        }\r\n    };\r\n\r\n    const processRecurringTransactions = async () => {\r\n        try {\r\n            const response = await api.processRecurring(userId);\r\n            if (response.success) {\r\n                toast.success(`Processed ${response.count} transactions`);\r\n                await fetchFromApi();\r\n            }\r\n        } catch (error) {\r\n            console.error('Error processing recurring transactions:', error);\r\n            toast.error('Failed to process recurring transactions');\r\n        }\r\n    };\r\n\r\n    // --- Expenses ---\r\n    const createExpense = async (data: any) => {\r\n        try {\r\n            // 1. Calculate Available to Spend (Global Check)\r\n            // Re-calculate strictly to ensure latest state\r\n            const totalBankBalance = accounts.reduce((sum, acc) => sum + (acc.type !== 'credit_card' ? acc.balance : 0), 0);\r\n            const shadowWalletTotal = goals.reduce((sum, g) => sum + g.currentAmount, 0) + emergencyFundAmount;\r\n\r\n            // Calculate recurring commitments (simplified for now: sum of EMI + assuming some recurring ops)\r\n            //Ideally this comes from a hook, but calculating inline for atomicity\r\n            const totalCommitments = liabilities.reduce((sum, l) => sum + l.emiAmount, 0);\r\n\r\n            const availableToSpend = Math.max(0, totalBankBalance - shadowWalletTotal - totalCommitments);\r\n\r\n            const expenseAmount = data.amount;\r\n\r\n            // LEAKAGE PROTOCOL\r\n            if (expenseAmount > availableToSpend) {\r\n                const deficit = expenseAmount - availableToSpend;\r\n                console.warn(` Leakage Detected! Deficit: ${deficit}. Initiating Shadow Wallet Protocol.`);\r\n\r\n                let remainingDeficit = deficit;\r\n                const assetsToDrain: { id: string, type: 'goal' | 'emergency', currentAmount: number, priority: number, name: string }[] = [];\r\n\r\n                // 2. Identify and Sort Liquid Assets\r\n                // Priority: 1. Growth (Drain First), 2. Stability, 3. Protection (Drain Last)\r\n                goals.forEach(g => {\r\n                    const type = g.type || 'growth';\r\n                    let priority = 1; // Default/Growth\r\n                    if (type === 'stability') priority = 2;\r\n                    if (type === 'protection') priority = 3;\r\n\r\n                    if (g.currentAmount > 0) {\r\n                        assetsToDrain.push({\r\n                            id: g.id,\r\n                            type: 'goal',\r\n                            currentAmount: g.currentAmount,\r\n                            priority,\r\n                            name: g.name\r\n                        });\r\n                    }\r\n                });\r\n\r\n                if (emergencyFundAmount > 0) {\r\n                    assetsToDrain.push({\r\n                        id: 'emergency-fund',\r\n                        type: 'emergency',\r\n                        currentAmount: emergencyFundAmount,\r\n                        priority: 3, // Protection/Highest Importance -> Drain Last\r\n                        name: 'Emergency Fund'\r\n                    });\r\n                }\r\n\r\n                // Sort: Drain lower priority (Start of array) first. \r\n                // Wait... Requirement: \"Subtract from Growth... then Stability... then Protection\"\r\n                // So Growth is \"First to be sacrificed\".\r\n                // Priority 1 (Growth) < Priority 3 (Protection).\r\n                assetsToDrain.sort((a, b) => a.priority - b.priority);\r\n\r\n                // 3. Drain Logic\r\n                const updatesToPerform: Promise<any>[] = [];\r\n                const notificationsToSend: Notification[] = [];\r\n\r\n                for (const asset of assetsToDrain) {\r\n                    if (remainingDeficit <= 0) break;\r\n\r\n                    const amountToTake = Math.min(asset.currentAmount, remainingDeficit);\r\n                    remainingDeficit -= amountToTake;\r\n\r\n                    if (asset.type === 'goal') {\r\n                        const newAmount = asset.currentAmount - amountToTake;\r\n                        // Determine new status: if taking anything, it's leaking.\r\n                        updatesToPerform.push(updateGoal(asset.id, {\r\n                            currentAmount: newAmount,\r\n                            status: 'leaking'\r\n                        }));\r\n\r\n                        // Check if we already notified about this wallet today? \r\n                        // Simplified: Just add notification now, debounce locally if needed.\r\n                        notificationsToSend.push({\r\n                            id: `leak_${asset.id}_${new Date().toISOString().split('T')[0]}`, // ID based on day\r\n                            type: 'alert',\r\n                            priority: 'medium',\r\n                            category: 'transactions',\r\n                            title: 'Shadow Wallet Leakage',\r\n                            message: `${amountToTake} spent reduced your '${asset.name}' reserve.`,\r\n                            timestamp: new Date(),\r\n                            read: false\r\n                        });\r\n\r\n                    } else if (asset.type === 'emergency') {\r\n                        updatesToPerform.push(Promise.resolve(setEmergencyFundAmount(prev => prev - amountToTake))); // Local update wrapper\r\n                        // Also persist to storage? updateGoal handles it, but emergency fund is raw state.\r\n                        // We manually trigger the storage effect by setting state.\r\n\r\n                        notificationsToSend.push({\r\n                            id: `leak_emergency_${new Date().toISOString().split('T')[0]}`, // ID based on day\r\n                            type: 'alert',\r\n                            priority: 'medium',\r\n                            category: 'transactions',\r\n                            title: 'Emergency Fund Alert',\r\n                            message: `Warning: ${amountToTake} withdrawn from Emergency Fund to cover spending.`,\r\n                            timestamp: new Date(),\r\n                            read: false\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // Execute Drains\r\n                await Promise.all(updatesToPerform);\r\n\r\n                // Send Notifications (Unique only)\r\n                if (notificationsToSend.length > 0) {\r\n                    addNotifications(notificationsToSend);\r\n                    notificationsToSend.forEach(n => toast.error(n.title, { description: n.message }));\r\n                }\r\n            }\r\n\r\n            // 4. Credit Card Interaction Logic\r\n            const targetAccount = accounts.find(a => a.id === data.accountId);\r\n            const processedData = { ...data };\r\n\r\n            if (targetAccount?.type === 'credit_card') {\r\n                // Calculate Service Charges\r\n                const serviceChargeRate = targetAccount.serviceChargePercentage || 0;\r\n                if (serviceChargeRate > 0) {\r\n                    const charge = (data.amount * serviceChargeRate) / 100;\r\n                    processedData.serviceChargeAmount = charge;\r\n                    // Note: We don't automatically add charge to amount here, \r\n                    // we just track it. The user might want it separate.\r\n                    console.log(`Credit Service Charge: ${charge}`);\r\n                }\r\n\r\n                // Safe Limit Monitoring\r\n                const creditLimit = targetAccount.creditLimit || 0;\r\n                const safePercentage = targetAccount.safeLimitPercentage || 30; // Default to 30% if not set\r\n                const safeLimit = (creditLimit * safePercentage) / 100;\r\n\r\n                // Assuming account.balance for CC represents current usage (spent amount)\r\n                const currentUsage = Math.abs(targetAccount.balance);\r\n                const projectedUsage = currentUsage + data.amount;\r\n\r\n                if (projectedUsage > safeLimit && creditLimit > 0) {\r\n                    if (!data.isIncomeGenerating) {\r\n                        toast.warning(\"High Interest Risk Detected\", {\r\n                            description: `This transaction puts your CC usage at ${((projectedUsage / creditLimit) * 100).toFixed(1)}%, exceeding your ${safePercentage}% safe limit with no income-justification.`,\r\n                            duration: 6000\r\n                        });\r\n\r\n                        // Create a system notification for the breach\r\n                        const breachNotif: Notification = {\r\n                            id: `cc_limit_${targetAccount.id}_${new Date().toISOString().split('T')[0]}`, // Daily breach limit\r\n                            type: 'alert',\r\n                            priority: 'medium',\r\n                            category: 'transactions',\r\n                            title: 'Credit Stability Breach',\r\n                            message: `Card '${targetAccount.name}' usage protocol exceeded ${safePercentage}% threshold. Avoid non-essential outflow.`,\r\n                            timestamp: new Date(),\r\n                            read: false\r\n                        };\r\n                        addNotifications(breachNotif);\r\n                    } else {\r\n                        toast.info(\"Strategic Credit Utilization\", {\r\n                            description: \"Limit exceeded, but marked as income-generating. Proceed with caution.\"\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 5. Subscription Auto-Detect (Future Entries Protection)\r\n            if (!processedData.category || processedData.category === 'Other') {\r\n                const suggestion = autoCategorize(processedData.description);\r\n                if (suggestion && suggestion.category === 'Subscription') {\r\n                    processedData.category = 'Subscription';\r\n                    processedData.tags = Array.from(new Set([...(processedData.tags || []), 'auto-detected']));\r\n                }\r\n            }\r\n\r\n            // NEW: Formal Liability Registration\r\n            if (data.registerAsLiability) {\r\n                try {\r\n                    const tenureMonths = data.tenureUnit === 'years' ? (data.tenure * 12) : data.tenure;\r\n                    const libRes = await api.createLiability(userId, {\r\n                        name: data.description,\r\n                        type: data.liabilityType || 'other',\r\n                        principal: data.principal || data.amount,\r\n                        outstanding: data.principal || data.amount,\r\n                        interestRate: data.interestRate || 0,\r\n                        emiAmount: data.amount,\r\n                        startDate: data.date,\r\n                        tenure: tenureMonths,\r\n                        accountId: data.accountId\r\n                    });\r\n\r\n                    if (libRes.success) {\r\n                        processedData.liabilityId = libRes.liability.id;\r\n                        setLiabilities(prev => [...prev, libRes.liability]);\r\n                        toast.success(\"New loan registered in Bills tab\");\r\n\r\n                        // Note: createLiability normally creates a recurring transaction automatically.\r\n                        // To avoid duplicates, we'll mark this request as already having handled recurring.\r\n                        data.isRecurring = false;\r\n                    }\r\n                } catch (libErr) {\r\n                    console.error(\"Failed to auto-register liability:\", libErr);\r\n                }\r\n            }\r\n\r\n            // 6. Proceed with Expense Creation (Normal Flow)\r\n            const response = await api.createExpense(userId, processedData);\r\n            if (response.success) {\r\n                setExpenses(prev => [...prev, response.expense]);\r\n\r\n                // Update account balance\r\n                if (targetAccount) {\r\n                    const balanceChange = data.amount + (processedData.serviceChargeAmount || 0);\r\n                    // For Credit Cards: balance represents usage (debt), so we add the expense amount.\r\n                    // For Bank/Cash: balance represents current funds, so we subtract the expense amount.\r\n                    const newBalance = targetAccount.type === 'credit_card'\r\n                        ? targetAccount.balance + balanceChange\r\n                        : targetAccount.balance - balanceChange;\r\n\r\n                    await updateAccount(targetAccount.id, {\r\n                        balance: newBalance\r\n                    });\r\n                }\r\n\r\n                // Update Liability Outstanding (Synchronization logic)\r\n                if (processedData.liabilityId) {\r\n                    const targetLiability = liabilities.find(l => l.id === processedData.liabilityId);\r\n                    if (targetLiability) {\r\n                        const newOutstanding = Math.max(0, targetLiability.outstanding - data.amount);\r\n                        await updateLiability(targetLiability.id, {\r\n                            outstanding: newOutstanding\r\n                        });\r\n                        toast.info(`Updated '${targetLiability.name}' balance`, {\r\n                            description: `New outstanding: ${newOutstanding.toLocaleString()}`\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (data.isRecurring) {\r\n                    const recurringData = {\r\n                        type: 'expense',\r\n                        description: data.description,\r\n                        amount: data.amount,\r\n                        category: data.category,\r\n                        accountId: data.accountId,\r\n                        frequency: data.frequency || 'monthly',\r\n                        customIntervalDays: data.customIntervalDays,\r\n                        startDate: data.date, // Use the SAME date to trigger backfill analysis for historical gap\r\n                        endDate: data.endDate,\r\n                        tags: data.tags\r\n                    };\r\n                    await createRecurringTransaction(recurringData);\r\n                } else {\r\n                    toast.success(\"Expense added!\");\r\n\r\n                    // Verify to Automate Logic: If it's a known subscription but NOT marked recurring, ask user.\r\n                    if (isKnownSubscription(data.description) && !data.isRecurring) {\r\n                        const verifyNotif: Notification = {\r\n                            id: `verify_sub_${response.expense.id}`,\r\n                            type: 'insight',\r\n                            priority: 'medium',\r\n                            category: 'transactions',\r\n                            title: 'Automate Payment?',\r\n                            message: `Detected '${data.description}' as a subscription. Add to cyclical routine?`,\r\n                            timestamp: new Date(),\r\n                            read: false,\r\n                            action: {\r\n                                type: 'verify_subscription',\r\n                                label: 'Automate',\r\n                                status: 'pending',\r\n                                payload: {\r\n                                    id: response.expense.id,\r\n                                    description: data.description,\r\n                                    amount: data.amount,\r\n                                    category: data.category,\r\n                                    accountId: data.accountId,\r\n                                    date: data.date\r\n                                }\r\n                            }\r\n                        };\r\n                        addNotifications(verifyNotif);\r\n                    }\r\n                }\r\n            }\r\n        } catch {\r\n            console.error(\"Create expense failed\");\r\n            // Offline fallback\r\n            const tempExpense = {\r\n                id: `temp_${Date.now()}`,\r\n                ...data,\r\n                createdAt: new Date().toISOString()\r\n            };\r\n            setExpenses(prev => [...prev, tempExpense]);\r\n            toast.warning(\"Added in offline mode\");\r\n        }\r\n    };\r\n\r\n    const updateExpense = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateExpense(userId, id, data);\r\n            if (response.success) {\r\n                const oldExpense = expenses.find(e => e.id === id);\r\n                if (oldExpense) {\r\n                    // 1. Reverse old expense effect\r\n                    const oldAccount = accounts.find(a => a.id === oldExpense.accountId);\r\n                    if (oldAccount) {\r\n                        const amount = oldExpense.amount + (oldExpense.serviceChargeAmount || 0);\r\n                        const oldBalance = oldAccount.type === 'credit_card'\r\n                            ? oldAccount.balance - amount\r\n                            : oldAccount.balance + amount;\r\n                        await updateAccount(oldAccount.id, { balance: oldBalance });\r\n                    }\r\n\r\n                    // 2. Apply new expense effect (using latest state of accounts after reversal)\r\n                    // Note: We need to find the account again or use the updated response accountId\r\n                    const newExpense = response.expense;\r\n                    const newAccount = accounts.find(a => a.id === newExpense.accountId);\r\n                    if (newAccount) {\r\n                        const amount = newExpense.amount + (newExpense.serviceChargeAmount || 0);\r\n                        const newBalance = newAccount.type === 'credit_card'\r\n                            ? newAccount.balance + amount\r\n                            : newAccount.balance - amount;\r\n                        await updateAccount(newAccount.id, { balance: newBalance });\r\n                    }\r\n                    if (data.isRecurring) {\r\n                        if (oldExpense.recurringId) {\r\n                            await updateRecurringTransaction(oldExpense.recurringId, {\r\n                                amount: data.amount,\r\n                                description: data.description,\r\n                                category: data.category,\r\n                                tags: data.tags,\r\n                                frequency: data.frequency,\r\n                                customIntervalDays: data.customIntervalDays,\r\n                                endDate: data.endDate\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: data.description,\r\n                                amount: data.amount,\r\n                                category: data.category,\r\n                                accountId: data.accountId,\r\n                                frequency: data.frequency || 'monthly',\r\n                                customIntervalDays: data.customIntervalDays,\r\n                                startDate: oldExpense.date, // Use original transaction date for historical analysis\r\n                                endDate: data.endDate,\r\n                                tags: data.tags\r\n                            });\r\n                        }\r\n                    } else if (oldExpense.recurringId) {\r\n                        await deleteRecurringTransaction(oldExpense.recurringId);\r\n                    }\r\n                }\r\n\r\n                setExpenses(prev => prev.map(e => e.id === id ? response.expense : e));\r\n                toast.success(\"Expense updated\");\r\n            }\r\n        } catch {\r\n            // Offline update\r\n            setExpenses(prev => prev.map(e => e.id === id ? { ...e, ...data } : e));\r\n            toast.warning(\"Updated in offline mode\");\r\n        }\r\n    };\r\n\r\n    const deleteExpense = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteExpense(userId, id);\r\n            if (response.success) {\r\n                const expense = expenses.find(e => e.id === id);\r\n                if (expense) {\r\n                    const targetAccount = accounts.find(a => a.id === expense.accountId);\r\n                    if (targetAccount) {\r\n                        const amount = expense.amount + (expense.serviceChargeAmount || 0);\r\n                        const newBalance = targetAccount.type === 'credit_card'\r\n                            ? targetAccount.balance - amount // Restore credit card limit (reduce usage)\r\n                            : targetAccount.balance + amount; // Restore bank balance\r\n\r\n                        await updateAccount(targetAccount.id, { balance: newBalance });\r\n                    }\r\n                }\r\n                setExpenses(prev => prev.filter(e => e.id !== id));\r\n                toast.success(\"Expense deleted\");\r\n            }\r\n        } catch {\r\n            setExpenses(prev => prev.filter(e => e.id !== id));\r\n            toast.warning(\"Deleted in offline mode\");\r\n        }\r\n    };\r\n\r\n    // --- Incomes ---\r\n    const createIncome = async (data: any) => {\r\n        try {\r\n            const response = await api.createIncome(userId, data);\r\n            if (response.success) {\r\n                setIncomes(prev => [...prev, response.income]);\r\n\r\n                // Update account balance\r\n                const targetAccount = accounts.find(a => a.id === data.accountId);\r\n                if (targetAccount) {\r\n                    // For Credit Cards: Income reduces usage (debt).\r\n                    // For Bank/Cash: Income increases funds.\r\n                    const newBalance = targetAccount.type === 'credit_card'\r\n                        ? targetAccount.balance - data.amount\r\n                        : targetAccount.balance + data.amount;\r\n\r\n                    await updateAccount(targetAccount.id, {\r\n                        balance: newBalance\r\n                    });\r\n                }\r\n\r\n                if (data.isRecurring) {\r\n                    const recurringData = {\r\n                        type: 'income',\r\n                        source: data.source,\r\n                        amount: data.amount,\r\n                        accountId: data.accountId,\r\n                        frequency: data.frequency || 'monthly',\r\n                        customIntervalDays: data.customIntervalDays,\r\n                        startDate: data.date, // Use the SAME date to trigger backfill analysis for historical gap\r\n                        endDate: data.endDate,\r\n                        tags: data.tags\r\n                    };\r\n                    await createRecurringTransaction(recurringData);\r\n                } else {\r\n                    toast.success(\"Income added!\");\r\n                }\r\n            }\r\n        } catch {\r\n            const tempIncome = {\r\n                id: `temp_${Date.now()}`,\r\n                ...data,\r\n                createdAt: new Date().toISOString()\r\n            };\r\n            setIncomes(prev => [...prev, tempIncome]);\r\n            toast.warning(\"Added in offline mode\");\r\n        }\r\n    };\r\n\r\n    const updateIncome = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateIncome(userId, id, data);\r\n            if (response.success) {\r\n                const oldIncome = incomes.find(i => i.id === id);\r\n                if (oldIncome) {\r\n                    // 1. Reverse old income effect\r\n                    const oldAccount = accounts.find(a => a.id === oldIncome.accountId);\r\n                    if (oldAccount) {\r\n                        const oldBalance = oldAccount.type === 'credit_card'\r\n                            ? oldAccount.balance + oldIncome.amount\r\n                            : oldAccount.balance - oldIncome.amount;\r\n                        await updateAccount(oldAccount.id, { balance: oldBalance });\r\n                    }\r\n\r\n                    // 2. Apply new income effect\r\n                    const newIncome = response.income;\r\n                    const newAccount = accounts.find(a => a.id === newIncome.accountId);\r\n                    if (newAccount) {\r\n                        const newBalance = newAccount.type === 'credit_card'\r\n                            ? newAccount.balance - newIncome.amount\r\n                            : newAccount.balance + newIncome.amount;\r\n                        await updateAccount(newAccount.id, { balance: newBalance });\r\n                    }\r\n\r\n                    if (data.isRecurring) {\r\n                        if (oldIncome.recurringId) {\r\n                            await updateRecurringTransaction(oldIncome.recurringId, {\r\n                                amount: data.amount,\r\n                                source: data.source,\r\n                                description: data.source,\r\n                                category: data.category,\r\n                                tags: data.tags,\r\n                                frequency: data.frequency,\r\n                                customIntervalDays: data.customIntervalDays,\r\n                                endDate: data.endDate\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'income',\r\n                                description: data.source,\r\n                                source: data.source,\r\n                                amount: data.amount,\r\n                                category: data.category,\r\n                                accountId: data.accountId,\r\n                                frequency: data.frequency || 'monthly',\r\n                                customIntervalDays: data.customIntervalDays,\r\n                                startDate: oldIncome.date,\r\n                                endDate: data.endDate,\r\n                                tags: data.tags\r\n                            });\r\n                        }\r\n                    } else if (oldIncome.recurringId) {\r\n                        // If it was recurring but now it's not, delete the recurring transaction\r\n                        await deleteRecurringTransaction(oldIncome.recurringId);\r\n                    }\r\n                }\r\n                setIncomes(prev => prev.map(i => i.id === id ? response.income : i));\r\n                toast.success(\"Income updated\");\r\n            }\r\n        } catch {\r\n            setIncomes(prev => prev.map(i => i.id === id ? { ...i, ...data } : i));\r\n            toast.warning(\"Updated in offline mode\");\r\n        }\r\n    };\r\n\r\n    const deleteIncome = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteIncome(userId, id);\r\n            if (response.success) {\r\n                const income = incomes.find(i => i.id === id);\r\n                if (income) {\r\n                    const targetAccount = accounts.find(a => a.id === income.accountId);\r\n                    if (targetAccount) {\r\n                        const newBalance = targetAccount.type === 'credit_card'\r\n                            ? targetAccount.balance + income.amount // Reverse income effect on CC (increase usage)\r\n                            : targetAccount.balance - income.amount; // Reverse income effect on bank\r\n\r\n                        await updateAccount(targetAccount.id, { balance: newBalance });\r\n                    }\r\n                }\r\n                setIncomes(prev => prev.filter(i => i.id !== id));\r\n                toast.success(\"Income deleted\");\r\n            }\r\n        } catch {\r\n            setIncomes(prev => prev.filter(i => i.id !== id));\r\n            toast.warning(\"Deleted in offline mode\");\r\n        }\r\n    };\r\n\r\n    // --- Debts ---\r\n    const createDebt = async (data: any) => {\r\n        try {\r\n            const response = await api.createDebt(userId, data);\r\n            if (response.success) {\r\n                setDebts(prev => [...prev, response.debt]);\r\n\r\n                // Update account balance\r\n                const targetAccount = accounts.find(a => a.id === data.accountId);\r\n                if (targetAccount) {\r\n                    // Type: 'borrowed' -> Cash increases, 'lent' -> Cash decreases\r\n                    const balanceChange = data.type === 'borrowed' ? data.amount : -data.amount;\r\n\r\n                    // CC Consideration: Borrowing to CC is weird but theoretically possible (cash advance).\r\n                    // Lending from CC is also possible.\r\n                    const newBalance = targetAccount.type === 'credit_card'\r\n                        ? targetAccount.balance - balanceChange // Usage decreases if borrowed (added to card), usage increases if lent\r\n                        : targetAccount.balance + balanceChange;\r\n\r\n                    await updateAccount(targetAccount.id, {\r\n                        balance: newBalance\r\n                    });\r\n                }\r\n\r\n                if (data.isRecurring) {\r\n                    await createRecurringTransaction({\r\n                        type: 'expense', // Debts are currently tracked as simple ledger entries, using 'expense' type for recurring\r\n                        description: `Debt: ${data.personName} (${data.type})`,\r\n                        amount: data.amount,\r\n                        category: 'Debt',\r\n                        accountId: data.accountId,\r\n                        frequency: data.frequency || 'monthly',\r\n                        startDate: data.date,\r\n                        tags: [...(data.tags || []), 'debt']\r\n                    });\r\n                }\r\n\r\n                toast.success(\"Debt created\");\r\n            }\r\n        } catch {\r\n            const tempDebt = {\r\n                id: `temp_${Date.now()}`,\r\n                ...data,\r\n                status: 'pending',\r\n                createdAt: new Date().toISOString()\r\n            };\r\n            setDebts(prev => [...prev, tempDebt]);\r\n            toast.warning(\"Added in offline mode\");\r\n        }\r\n    };\r\n\r\n    const updateDebt = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateDebt(userId, id, data);\r\n            if (response.success) {\r\n                const oldDebt = debts.find(d => d.id === id);\r\n                if (oldDebt) {\r\n                    // 1. Reverse old debt effect\r\n                    const oldAccount = accounts.find(a => a.id === oldDebt.accountId);\r\n                    if (oldAccount) {\r\n                        const balanceChange = oldDebt.type === 'borrowed' ? -oldDebt.amount : oldDebt.amount;\r\n                        const oldBalance = oldAccount.type === 'credit_card'\r\n                            ? oldAccount.balance - balanceChange\r\n                            : oldAccount.balance + balanceChange;\r\n                        await updateAccount(oldAccount.id, { balance: oldBalance });\r\n                    }\r\n\r\n                    // 2. Apply new debt effect\r\n                    const newDebt = response.debt;\r\n                    const newAccount = accounts.find(a => a.id === newDebt.accountId);\r\n                    if (newAccount) {\r\n                        const balanceChange = newDebt.type === 'borrowed' ? newDebt.amount : -newDebt.amount;\r\n                        const newBalance = newAccount.type === 'credit_card'\r\n                            ? newAccount.balance - balanceChange\r\n                            : newAccount.balance + balanceChange;\r\n                        await updateAccount(newAccount.id, { balance: newBalance });\r\n                    }\r\n                    if (data.isRecurring) {\r\n                        // Logic to handle update or creation of recurring from updateDebt\r\n                        // For now, if it was already recurring, updateRecurringTransaction should be called.\r\n                        // If toggled ON, create new.\r\n                        if (oldDebt.recurringId) {\r\n                            await updateRecurringTransaction(oldDebt.recurringId, {\r\n                                amount: data.amount,\r\n                                description: `Debt: ${data.personName} (${data.type})`\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: `Debt: ${data.personName} (${data.type})`,\r\n                                amount: data.amount,\r\n                                category: 'Debt',\r\n                                accountId: data.accountId,\r\n                                frequency: data.frequency || 'monthly',\r\n                                startDate: data.date,\r\n                                tags: [...(data.tags || []), 'debt']\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                setDebts(prev => prev.map(d => d.id === id ? response.debt : d));\r\n                toast.success(\"Debt updated\");\r\n            }\r\n        } catch {\r\n            setDebts(prev => prev.map(d => d.id === id ? { ...d, ...data } : d));\r\n            toast.warning(\"Updated in offline mode\");\r\n        }\r\n    };\r\n\r\n    const deleteDebt = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteDebt(userId, id);\r\n            if (response.success) {\r\n                const debt = debts.find(d => d.id === id);\r\n                if (debt) {\r\n                    const targetAccount = accounts.find(a => a.id === debt.accountId);\r\n                    if (targetAccount) {\r\n                        // Reverse the initial balance change\r\n                        const balanceChange = debt.type === 'borrowed' ? -debt.amount : debt.amount;\r\n                        const newBalance = targetAccount.type === 'credit_card'\r\n                            ? targetAccount.balance - balanceChange\r\n                            : targetAccount.balance + balanceChange;\r\n\r\n                        await updateAccount(targetAccount.id, { balance: newBalance });\r\n                    }\r\n                }\r\n                setDebts(prev => prev.filter(d => d.id !== id));\r\n                toast.success(\"Debt deleted\");\r\n            }\r\n        } catch {\r\n            setDebts(prev => prev.filter(d => d.id !== id));\r\n            toast.warning(\"Deleted in offline mode\");\r\n        }\r\n    };\r\n\r\n    const settleDebt = async (id: string) => {\r\n        try {\r\n            const response = await api.updateDebt(userId, id, { status: \"settled\" });\r\n            if (response.success) {\r\n                const debt = debts.find(d => d.id === id);\r\n                if (debt && debt.status !== 'settled') {\r\n                    const targetAccount = accounts.find(a => a.id === debt.accountId);\r\n                    if (targetAccount) {\r\n                        // Settlement reverses the initial debt flow\r\n                        // borrowed -> payback (outflow), lent -> received back (inflow)\r\n                        const settlementAmount = debt.type === 'borrowed' ? -debt.amount : debt.amount;\r\n\r\n                        const newBalance = targetAccount.type === 'credit_card'\r\n                            ? targetAccount.balance - settlementAmount\r\n                            : targetAccount.balance + settlementAmount;\r\n\r\n                        await updateAccount(targetAccount.id, { balance: newBalance });\r\n\r\n                        // Record the settlement as a Transfer to avoid double-counting as spending/income\r\n                        const settlementTransaction = {\r\n                            description: `Debt Settlement: ${debt.personName}`,\r\n                            amount: debt.amount,\r\n                            category: 'Transfer',\r\n                            date: new Date().toISOString().split('T')[0],\r\n                            tags: ['debt-settlement'],\r\n                            accountId: debt.accountId\r\n                        };\r\n\r\n                        if (debt.type === 'borrowed') {\r\n                            const res = await api.createExpense(userId, settlementTransaction);\r\n                            if (res.success) setExpenses(prev => [...prev, res.expense]);\r\n                        } else {\r\n                            const res = await api.createIncome(userId, settlementTransaction);\r\n                            if (res.success) setIncomes(prev => [...prev, res.income]);\r\n                        }\r\n                    }\r\n                }\r\n                setDebts(prev => prev.map(d => d.id === id ? response.debt : d));\r\n                toast.success(\" Debt settled! Great job!\");\r\n                confetti({ particleCount: 150, spread: 100, origin: { y: 0.6 } });\r\n            }\r\n        } catch {\r\n            setDebts(prev => prev.map(d => d.id === id ? { ...d, status: \"settled\" as const } : d));\r\n            toast.warning(\"Marked as settled locally\");\r\n        }\r\n    };\r\n\r\n    // --- Migration ---\r\n    const migrateSubscriptions = async (): Promise<{ count: number }> => {\r\n        let updateCount = 0;\r\n        const updates: Promise<any>[] = [];\r\n\r\n        // 1. Scan Expenses\r\n        for (const expense of expenses) {\r\n            // Only update if not already a Subscription and matches DB\r\n            if (expense.category !== 'Subscription' && isKnownSubscription(expense.description)) {\r\n\r\n                // Get precise details if available\r\n                const details = autoCategorize(expense.description);\r\n\r\n                if (details && details.category === 'Subscription') {\r\n                    updates.push(updateExpense(expense.id, {\r\n                        category: 'Subscription',\r\n                        tags: [...new Set([...expense.tags, 'auto-migrated', 'subscription'])]\r\n                    }));\r\n                    updateCount++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (updates.length > 0) {\r\n            await Promise.all(updates);\r\n            toast.success(`Migrated ${updateCount} transactions to Subscriptions`);\r\n        } else {\r\n            toast.info(\"No subscription transactions found to migrate\");\r\n        }\r\n\r\n        return { count: updateCount };\r\n    };\r\n\r\n    const cleanupDuplicates = async (): Promise<{ count: number }> => {\r\n        let removedCount = 0;\r\n        const updates: Promise<any>[] = [];\r\n        const seen = new Set<string>();\r\n\r\n        // 1. Exact Duplicate & Blank Scan\r\n        const expensesToDelete = new Set<string>();\r\n\r\n        // Exact Match Logic\r\n        expenses.forEach(expense => {\r\n            const key = `${expense.date}-${expense.description?.toLowerCase().trim()}-${expense.amount}`;\r\n            const isBlank = !expense.description || expense.description.trim() === '' || expense.amount === 0;\r\n            const isDuplicate = seen.has(key);\r\n\r\n            if (isBlank || isDuplicate) {\r\n                expensesToDelete.add(expense.id);\r\n            } else {\r\n                seen.add(key);\r\n            }\r\n        });\r\n\r\n        // 2. Subscription Density Scan (Smart Dedupe)\r\n        // Group by Subscription Name + Month\r\n        const subGroups = new Map<string, Expense[]>();\r\n\r\n        expenses.forEach(e => {\r\n            // Only check active candidates not already marked for deletion\r\n            if (expensesToDelete.has(e.id)) return;\r\n\r\n            const isSub = e.category === 'Subscription' || e.isRecurring || isKnownSubscription(e.description);\r\n            if (isSub) {\r\n                const date = new Date(e.date);\r\n                const key = `${e.description.toLowerCase().trim()}-${date.getFullYear()}-${date.getMonth()}`;\r\n\r\n                if (!subGroups.has(key)) subGroups.set(key, []);\r\n                subGroups.get(key)!.push(e);\r\n            }\r\n        });\r\n\r\n        // Enforce 1 per month policy\r\n        subGroups.forEach((group) => {\r\n            if (group.length > 1) {\r\n                // Sort: Prefer entries that are explicitly marked recurring, then by latest date/creation\r\n                group.sort((a, b) => {\r\n                    if (a.isRecurring !== b.isRecurring) return a.isRecurring ? -1 : 1; // Keep recurring\r\n                    return new Date(b.date).getTime() - new Date(a.date).getTime(); // Keep latest\r\n                });\r\n\r\n                // Keep the first one (Index 0), delete the rest\r\n                for (let i = 1; i < group.length; i++) {\r\n                    expensesToDelete.add(group[i].id);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Execute Expense Deletions\r\n        expensesToDelete.forEach(id => {\r\n            updates.push(deleteExpense(id));\r\n            removedCount++;\r\n        });\r\n\r\n        // 3. Scan Incomes (Exact Only)\r\n        const seenIncomes = new Set<string>();\r\n        for (const income of incomes) {\r\n            const key = `${income.date}-${income.source?.toLowerCase().trim()}-${income.amount}`;\r\n            const isBlank = !income.source || income.source.trim() === '' || income.amount === 0;\r\n            const isDuplicate = seenIncomes.has(key);\r\n\r\n            if (isBlank || isDuplicate) {\r\n                updates.push(deleteIncome(income.id));\r\n                removedCount++;\r\n            } else {\r\n                seenIncomes.add(key);\r\n            }\r\n        }\r\n\r\n        if (updates.length > 0) {\r\n            await Promise.all(updates);\r\n            toast.success(`Cleaned up ${removedCount} entries (Duplicates & Density Checks)`);\r\n        } else {\r\n            toast.info(\"Logs are clean. No redundancies found.\");\r\n        }\r\n\r\n        return { count: removedCount };\r\n    };\r\n\r\n    // --- Goals ---\r\n    const createGoal = async (data: any) => {\r\n        try {\r\n            const response = await api.createGoal(userId, data);\r\n            if (response.success) {\r\n                setGoals(prev => [...prev, response.goal]);\r\n\r\n                if (data.monthly_contribution > 0) {\r\n                    await createRecurringTransaction({\r\n                        type: 'expense',\r\n                        description: `Goal Contribution: ${response.goal.name}`,\r\n                        amount: data.monthly_contribution,\r\n                        category: 'Transfer',\r\n                        accountId: data.accountId || 'none',\r\n                        frequency: 'monthly',\r\n                        startDate: data.startDate || response.goal.createdAt.split('T')[0],\r\n                        tags: ['goal', 'contribution', response.goal.name.toLowerCase()],\r\n                        goalId: response.goal.id\r\n                    });\r\n                }\r\n\r\n                toast.success(\"Goal created\");\r\n            }\r\n        } catch {\r\n            const temp = { id: `temp_${Date.now()}`, ...data, createdAt: new Date().toISOString() };\r\n            setGoals(prev => [...prev, temp]);\r\n            toast.warning(\"Created in offline mode\");\r\n        }\r\n    };\r\n\r\n    const updateGoal = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateGoal(userId, id, data);\r\n            if (response.success) {\r\n                const oldGoal = goals.find(g => g.id === id);\r\n                if (oldGoal) {\r\n                    if ((response.goal.monthly_contribution || 0) > 0) {\r\n                        const existingRec = recurringTransactions.find(rt => rt.goalId === id);\r\n                        if (existingRec) {\r\n                            await updateRecurringTransaction(existingRec.id, {\r\n                                amount: response.goal.monthly_contribution || 0,\r\n                                description: `Goal Contribution: ${response.goal.name}`\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: `Goal Contribution: ${response.goal.name}`,\r\n                                amount: response.goal.monthly_contribution || 0,\r\n                                category: 'Transfer',\r\n                                accountId: response.goal.accountId || 'none',\r\n                                frequency: 'monthly',\r\n                                startDate: response.goal.startDate || oldGoal.createdAt?.split('T')[0] || new Date().toISOString().split('T')[0],\r\n                                tags: ['goal', 'contribution', response.goal.name.toLowerCase()],\r\n                                goalId: response.goal.id\r\n                            });\r\n                        }\r\n                    } else if (oldGoal.monthly_contribution && oldGoal.monthly_contribution > 0) {\r\n                        const existingRec = recurringTransactions.find(rt => rt.goalId === id);\r\n                        if (existingRec) await deleteRecurringTransaction(existingRec.id);\r\n                    }\r\n                }\r\n\r\n                setGoals(prev => prev.map(g => g.id === id ? response.goal : g));\r\n                if (response.goal.currentAmount >= response.goal.targetAmount) {\r\n                    toast.success(` Goal \"${response.goal.name}\" completed!`);\r\n                    confetti({ particleCount: 200, spread: 120, origin: { y: 0.5 } });\r\n                } else {\r\n                    toast.success(\"Goal updated\");\r\n                }\r\n            }\r\n        } catch {\r\n            setGoals(prev => prev.map(g => g.id === id ? { ...g, ...data } : g));\r\n            toast.warning(\"Updated locally\");\r\n        }\r\n    };\r\n\r\n    const deleteGoal = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteGoal(userId, id);\r\n            if (response.success) {\r\n                setGoals(prev => prev.filter(g => g.id !== id));\r\n                toast.success(\"Goal deleted\");\r\n            }\r\n        } catch {\r\n            setGoals(prev => prev.filter(g => g.id !== id));\r\n            toast.warning(\"Deleted locally\");\r\n        }\r\n    };\r\n\r\n    // --- Accounts ---\r\n    const createAccount = async (data: any) => {\r\n        try {\r\n            const response = await api.createAccount(userId, data);\r\n            if (response.success) {\r\n                setAccounts(prev => [...prev, response.account]);\r\n                toast.success(\"Account created\");\r\n            }\r\n        } catch {\r\n            const temp = { id: `temp_${Date.now()}`, ...data, createdAt: new Date().toISOString() };\r\n            setAccounts(prev => [...prev, temp]);\r\n            toast.warning(\"Created locally\");\r\n        }\r\n    };\r\n\r\n    const updateAccount = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateAccount(userId, id, data);\r\n            if (response.success) {\r\n                setAccounts(prev => prev.map(a => a.id === id ? response.account : a));\r\n                toast.success(\"Account updated\");\r\n            }\r\n        } catch {\r\n            setAccounts(prev => prev.map(a => a.id === id ? { ...a, ...data } : a));\r\n            toast.warning(\"Updated locally\");\r\n        }\r\n    };\r\n\r\n    const deleteAccount = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteAccount(userId, id);\r\n            if (response.success) {\r\n                setAccounts(prev => prev.filter(a => a.id !== id));\r\n                toast.success(\"Account deleted\");\r\n            }\r\n        } catch {\r\n            setAccounts(prev => prev.filter(a => a.id !== id));\r\n            toast.warning(\"Deleted locally\");\r\n        }\r\n    };\r\n\r\n    // --- Liabilities ---\r\n    const createLiability = async (data: Omit<Liability, 'id'>) => {\r\n        try {\r\n            const response = await api.createLiability(userId, data);\r\n            if (response.success) {\r\n                setLiabilities(prev => [...prev, response.liability]);\r\n                toast.success(\"Liability created\");\r\n\r\n                if (response.liability.emiAmount > 0) {\r\n                    await createRecurringTransaction({\r\n                        type: 'expense',\r\n                        description: `EMI: ${response.liability.name}`,\r\n                        amount: response.liability.emiAmount,\r\n                        category: 'EMI',\r\n                        accountId: response.liability.accountId || 'none',\r\n                        frequency: 'monthly',\r\n                        startDate: response.liability.startDate,\r\n                        tags: ['emi', 'liability', response.liability.name.toLowerCase()],\r\n                        liabilityId: response.liability.id\r\n                    });\r\n                }\r\n            }\r\n        } catch {\r\n            const temp = {\r\n                id: `temp_${Date.now()}`,\r\n                ...data,\r\n                principal: Number(data.principal),\r\n                outstanding: Number(data.outstanding),\r\n                interestRate: Number(data.interestRate),\r\n                emiAmount: Number(data.emiAmount),\r\n                tenure: Number(data.tenure),\r\n                createdAt: new Date().toISOString()\r\n            } as Liability;\r\n            setLiabilities(prev => [...prev, temp]);\r\n            toast.warning(\"Created locally\");\r\n        }\r\n    };\r\n\r\n    const updateLiability = async (id: string, data: Partial<Liability>) => {\r\n        try {\r\n            const response = await api.updateLiability(userId, id, data);\r\n            if (response.success) {\r\n                const oldLiability = liabilities.find(l => l.id === id);\r\n                if (oldLiability) {\r\n                    if (response.liability.emiAmount > 0) {\r\n                        const existingRec = recurringTransactions.find(rt => rt.liabilityId === id);\r\n                        if (existingRec) {\r\n                            await updateRecurringTransaction(existingRec.id, {\r\n                                amount: response.liability.emiAmount,\r\n                                description: `EMI: ${response.liability.name}`\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: `EMI: ${response.liability.name}`,\r\n                                amount: response.liability.emiAmount,\r\n                                category: 'EMI',\r\n                                accountId: response.liability.accountId || 'none',\r\n                                frequency: 'monthly',\r\n                                startDate: response.liability.startDate,\r\n                                tags: ['emi', 'liability', response.liability.name.toLowerCase()],\r\n                                liabilityId: response.liability.id\r\n                            });\r\n                        }\r\n                    } else if (oldLiability.emiAmount > 0) {\r\n                        const existingRec = recurringTransactions.find(rt => rt.liabilityId === id);\r\n                        if (existingRec) await deleteRecurringTransaction(existingRec.id);\r\n                    }\r\n                }\r\n                setLiabilities(prev => prev.map(l => l.id === id ? response.liability : l));\r\n                toast.success(\"Liability updated\");\r\n            }\r\n        } catch {\r\n            setLiabilities(prev => prev.map(l => l.id === id ? { ...l, ...data } as Liability : l));\r\n            toast.warning(\"Updated locally\");\r\n        }\r\n    };\r\n\r\n    const deleteLiability = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteLiability(userId, id);\r\n            if (response.success) {\r\n                setLiabilities(prev => prev.filter(l => l.id !== id));\r\n                toast.success(\"Liability deleted\");\r\n            }\r\n        } catch {\r\n            setLiabilities(prev => prev.filter(l => l.id !== id));\r\n            toast.warning(\"Deleted locally\");\r\n        }\r\n    };\r\n\r\n    // --- Investments ---\r\n    const createInvestment = async (data: any, sourceAccountId?: string) => {\r\n        try {\r\n            const response = await api.createInvestment(userId, data);\r\n            if (response.success) {\r\n                setInvestments(prev => [...prev, response.investment]);\r\n\r\n                // Aggregation Rule: Cash-to-Asset Logic\r\n                if (sourceAccountId && sourceAccountId !== 'none') {\r\n                    const sourceAccount = accounts.find(a => a.id === sourceAccountId);\r\n                    if (sourceAccount) {\r\n                        const cost = data.buyPrice * data.quantity;\r\n                        // Deduct from source\r\n                        await updateAccount(sourceAccountId, {\r\n                            balance: sourceAccount.balance - cost\r\n                        });\r\n\r\n                        // Record Transfer\r\n                        const transferData = {\r\n                            description: `Asset Purchase: ${data.symbol} (${data.quantity} units)`,\r\n                            amount: cost,\r\n                            category: 'Transfer',\r\n                            date: data.purchaseDate || new Date().toISOString().split('T')[0],\r\n                            tags: ['investment', 'principal', data.symbol],\r\n                            accountId: sourceAccountId\r\n                        };\r\n                        const tResponse = await api.createExpense(userId, transferData);\r\n                        if (tResponse.success) {\r\n                            setExpenses(prev => [...prev, tResponse.expense]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // SIP Recurring Support\r\n                if (response.investment.type === 'sip') {\r\n                    await createRecurringTransaction({\r\n                        type: 'expense',\r\n                        description: `SIP: ${response.investment.symbol} (${response.investment.name})`,\r\n                        amount: response.investment.buyPrice * response.investment.quantity,\r\n                        category: 'Investment',\r\n                        accountId: sourceAccountId || 'none',\r\n                        frequency: 'monthly',\r\n                        startDate: response.investment.purchaseDate,\r\n                        tags: ['sip', 'investment', response.investment.symbol.toLowerCase()],\r\n                        investmentId: response.investment.id\r\n                    });\r\n                }\r\n\r\n                toast.success(\"Investment created\");\r\n            }\r\n        } catch {\r\n            const temp = { id: `temp_${Date.now()}`, ...data, createdAt: new Date().toISOString() };\r\n            setInvestments(prev => [...prev, temp]);\r\n            toast.warning(\"Created locally\");\r\n        }\r\n    };\r\n\r\n    const updateInvestment = async (id: string, data: any) => {\r\n        try {\r\n            const response = await api.updateInvestment(userId, id, data);\r\n            if (response.success) {\r\n                const oldInv = investments.find(inv => inv.id === id);\r\n                if (oldInv) {\r\n                    if (response.investment.type === 'sip') {\r\n                        const existingRec = recurringTransactions.find(rt => rt.investmentId === id);\r\n                        if (existingRec) {\r\n                            await updateRecurringTransaction(existingRec.id, {\r\n                                amount: response.investment.buyPrice * response.investment.quantity,\r\n                                description: `SIP: ${response.investment.symbol} (${response.investment.name})`\r\n                            });\r\n                        } else {\r\n                            await createRecurringTransaction({\r\n                                type: 'expense',\r\n                                description: `SIP: ${response.investment.symbol} (${response.investment.name})`,\r\n                                amount: response.investment.buyPrice * response.investment.quantity,\r\n                                category: 'Investment',\r\n                                accountId: response.investment.accountId || 'none',\r\n                                frequency: 'monthly',\r\n                                startDate: response.investment.purchaseDate,\r\n                                tags: ['sip', 'investment', response.investment.symbol.toLowerCase()],\r\n                                investmentId: response.investment.id\r\n                            });\r\n                        }\r\n                    } else if (oldInv.type === 'sip') {\r\n                        const existingRec = recurringTransactions.find(rt => rt.investmentId === id);\r\n                        if (existingRec) await deleteRecurringTransaction(existingRec.id);\r\n                    }\r\n                }\r\n                setInvestments(prev => prev.map(inv => inv.id === id ? response.investment : inv));\r\n                toast.success(\"Investment updated\");\r\n            }\r\n        } catch {\r\n            setInvestments(prev => prev.map(i => i.id === id ? { ...i, ...data } : i));\r\n            toast.warning(\"Updated locally\");\r\n        }\r\n    };\r\n\r\n    const deleteInvestment = async (id: string) => {\r\n        try {\r\n            const response = await api.deleteInvestment(userId, id);\r\n            if (response.success) {\r\n                setInvestments(prev => prev.filter(i => i.id !== id));\r\n                toast.success(\"Investment deleted\");\r\n            }\r\n        } catch {\r\n            setInvestments(prev => prev.filter(i => i.id !== id));\r\n            toast.warning(\"Deleted locally\");\r\n        }\r\n    };\r\n\r\n\r\n    // --- Fund Allocation & Operations ---\r\n    const [isFundAllocationOpen, setIsFundAllocationOpen] = useState(false);\r\n    const [fundAllocationType, setFundAllocationType] = useState<'goal' | 'emergency'>('goal');\r\n\r\n    const openFundAllocation = (type: 'goal' | 'emergency') => {\r\n        setFundAllocationType(type);\r\n        setIsFundAllocationOpen(true);\r\n    };\r\n\r\n    const closeFundAllocation = () => {\r\n        setIsFundAllocationOpen(false);\r\n    };\r\n\r\n    const performFundAllocation = async (data: {\r\n        accountId: string;\r\n        destinationId: string;\r\n        amount: number;\r\n        destinationType: 'goal' | 'emergency';\r\n    }) => {\r\n        const account = accounts.find(a => a.id === data.accountId);\r\n        if (!account) {\r\n            toast.error('Account not found');\r\n            return;\r\n        }\r\n\r\n        if (account.balance < data.amount) {\r\n            toast.error(`Insufficient funds in ${account.name}`);\r\n            return;\r\n        }\r\n\r\n        // Update account balance\r\n        await updateAccount(data.accountId, {\r\n            balance: account.balance - data.amount\r\n        });\r\n\r\n        // Update goal or emergency fund\r\n        if (data.destinationType === 'goal') {\r\n            const goal = goals.find(g => g.id === data.destinationId);\r\n            if (goal) {\r\n                await updateGoal(data.destinationId, {\r\n                    currentAmount: goal.currentAmount + data.amount\r\n                });\r\n            }\r\n        } else {\r\n            setEmergencyFundAmount(prev => prev + data.amount);\r\n        }\r\n\r\n        toast.success(\r\n            `Successfully allocated ${CURRENCY_SYMBOLS[settings.currency]}${data.amount.toLocaleString()} from ${account.name}!`,\r\n            {\r\n                description: `${data.destinationType === 'goal' ? 'Goal' : 'Emergency Fund'} balance updated`\r\n            }\r\n        );\r\n        confetti({\r\n            particleCount: 100,\r\n            spread: 70,\r\n            origin: { y: 0.6 }\r\n        });\r\n    };\r\n\r\n    const deductFromAccount = async (accountId: string, amount: number) => {\r\n        const account = accounts.find(a => a.id === accountId);\r\n        if (account) {\r\n            if (account.balance < amount) {\r\n                toast.error(`Insufficient funds in ${account.name}`);\r\n                throw new Error('Insufficient funds');\r\n            }\r\n            await updateAccount(accountId, {\r\n                balance: account.balance - amount\r\n            });\r\n        }\r\n    };\r\n\r\n    const transferFunds = async (sourceId: string, destinationId: string, amount: number) => {\r\n        const sourceAccount = accounts.find(a => a.id === sourceId);\r\n        const destAccount = accounts.find(a => a.id === destinationId);\r\n\r\n        if (!sourceAccount || !destAccount) {\r\n            toast.error('Source or destination account not found');\r\n            return;\r\n        }\r\n\r\n        if (sourceAccount.balance < amount) {\r\n            toast.error(`Insufficient funds in ${sourceAccount.name}`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            // Update source: subtract\r\n            await updateAccount(sourceId, { balance: sourceAccount.balance - amount });\r\n\r\n            // Update destination: add (or subtract for CC to reduce debt)\r\n            const destBalanceChange = destAccount.type === 'credit_card' ? -amount : amount;\r\n            await updateAccount(destinationId, { balance: destAccount.balance + destBalanceChange });\r\n\r\n            // Record this migration as a transaction for history (but analytics will ignore it as 'Transfer')\r\n            const transferExpense = {\r\n                description: `Migration: ${sourceAccount.name}  ${destAccount.name}`,\r\n                amount: amount,\r\n                category: 'Transfer',\r\n                date: new Date().toISOString().split('T')[0],\r\n                tags: ['internal', 'migration'],\r\n                accountId: sourceId\r\n            };\r\n\r\n            // We use direct API call or internal createExpense to avoid recursive balance updates \r\n            // since we already updated balances above.\r\n            const response = await api.createExpense(userId, transferExpense);\r\n            if (response.success) {\r\n                setExpenses(prev => [...prev, response.expense]);\r\n            }\r\n\r\n            toast.success(`Transferred ${CURRENCY_SYMBOLS[settings.currency]}${amount.toLocaleString()}!`, {\r\n                description: `From ${sourceAccount.name} to ${destAccount.name}`\r\n            });\r\n\r\n            confetti({ particleCount: 50, spread: 60, origin: { y: 0.7 } });\r\n        } catch (error) {\r\n            console.error('Transfer failed', error);\r\n            toast.error('Capital migration protocol failed');\r\n        }\r\n    };\r\n\r\n\r\n\r\n    const clearAllData = async () => {\r\n        try {\r\n            const toastId = toast.loading('Initiating factory reset...');\r\n\r\n            // Helper to run deletions in parallel and ignore errors\r\n            const deleteGroup = async (items: any[], deleteFn: (uid: string, id: string) => Promise<any>) => {\r\n                const promises = items.map(item =>\r\n                    deleteFn(userId, item.id).catch(e => console.warn(`Failed to delete ${item.id}`, e))\r\n                );\r\n                await Promise.all(promises);\r\n            };\r\n\r\n            await Promise.all([\r\n                deleteGroup(recurringTransactions, api.deleteRecurring),\r\n                deleteGroup(expenses, api.deleteExpense),\r\n                deleteGroup(incomes, api.deleteIncome),\r\n                deleteGroup(debts, api.deleteDebt),\r\n                deleteGroup(goals, api.deleteGoal),\r\n                deleteGroup(investments, api.deleteInvestment),\r\n                deleteGroup(liabilities, api.deleteLiability)\r\n            ]);\r\n\r\n            // Reset All Accounts to Zero (Fix for \"Ghost Balance\" after wipe)\r\n            const accountResets = accounts.map(a =>\r\n                api.updateAccount(userId, a.id, { balance: 0 }).catch(e => console.warn(`Failed to reset ${a.name}`, e))\r\n            );\r\n            await Promise.all(accountResets);\r\n\r\n            // Refetch to clear state\r\n            await fetchFromApi();\r\n            toast.dismiss(toastId);\r\n            toast.success(\"All data purged. Clean slate initialized.\");\r\n        } catch (error) {\r\n            console.error(error);\r\n            toast.error(\"Partial purge only. Some data remains.\");\r\n        }\r\n    };\r\n\r\n    return (\r\n        <FinanceContext.Provider\r\n            value={{\r\n                userId,\r\n                // State\r\n                settings,\r\n                currency: settings.currency, // Expose currency\r\n                expenses,\r\n                incomes,\r\n                debts,\r\n                goals,\r\n                accounts,\r\n                investments,\r\n                liabilities,\r\n                recurringTransactions,\r\n                notifications,\r\n                emergencyFundAmount,\r\n                isLoading,\r\n                isRefreshing,\r\n                isOffline,\r\n                apiStatus,\r\n                isFundAllocationOpen,\r\n                fundAllocationType,\r\n\r\n                // Auth\r\n                authStatus,\r\n                currentUser,\r\n                isAwaitingPin,\r\n                isRememberedUser,\r\n                rememberedMobile,\r\n                authMessage,\r\n\r\n                // Actions\r\n                refreshData,\r\n                updateSettings,\r\n                checkIdentity,\r\n                login,\r\n                signup,\r\n                logout,\r\n                clearPendingSession,\r\n                scheduleAccountDeletion,\r\n                cancelAccountDeletion,\r\n                deletionDate,\r\n                sendOtp,\r\n                verifyOtp,\r\n                resetPin,\r\n                pendingMobile,\r\n\r\n                createExpense,\r\n                updateExpense,\r\n                deleteExpense,\r\n                createIncome,\r\n                updateIncome,\r\n                deleteIncome,\r\n                createDebt,\r\n                updateDebt,\r\n                deleteDebt,\r\n                settleDebt,\r\n                createGoal,\r\n                updateGoal,\r\n                deleteGoal,\r\n                createAccount,\r\n                updateAccount,\r\n                deleteAccount,\r\n                createLiability,\r\n                updateLiability,\r\n                deleteLiability,\r\n                migrateSubscriptions,\r\n                cleanupDuplicates,\r\n                createInvestment,\r\n                updateInvestment,\r\n                deleteInvestment,\r\n                createRecurringTransaction,\r\n                createRecurring: createRecurringTransaction, // Alias\r\n                updateRecurringTransaction,\r\n                deleteRecurringTransaction,\r\n                processRecurringTransactions,\r\n                setEmergencyFundAmount,\r\n                setNotifications,\r\n                applyTheme,\r\n\r\n                // Fund Allocation\r\n                openFundAllocation,\r\n                closeFundAllocation,\r\n                performFundAllocation,\r\n                deductFromAccount,\r\n                transferFunds,\r\n                clearAllData,\r\n\r\n                // Backfill Logic\r\n                backfillRequest,\r\n                setBackfillRequest,\r\n                executeBackfill\r\n            }}\r\n        >\r\n            {children}\r\n        </FinanceContext.Provider>\r\n    );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\data\\financial-quotes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\hooks\\useDeleteWithUndo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\hooks\\useShadowWallet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\services\\ai\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\services\\ai\\prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\services\\ai\\providers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\supabase\\functions\\server\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\supabase\\functions\\server\\kv_store.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\types\\images.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\achievements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\aiUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\architect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\autoCategorize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\budgetUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\financeCalculations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\gestures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\haptics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\insights.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\isTransfer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\numberFormat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\stockData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\utils\\supabase\\info.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\tailwind.config.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\GitHub\\Finbasev50-3\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}],"metadata":{"cwd":"D:\\GitHub\\Finbasev50-3","rulesMeta":{"react-hooks/exhaustive-deps":{"type":"suggestion","docs":{"description":"verifies the list of dependencies for Hooks like useEffect and similar","recommended":true,"url":"https://github.com/facebook/react/issues/14920"},"fixable":"code","hasSuggestions":true,"schema":[{"type":"object","additionalProperties":false,"enableDangerousAutofixThisMayCauseInfiniteLoops":false,"properties":{"additionalHooks":{"type":"string"},"enableDangerousAutofixThisMayCauseInfiniteLoops":{"type":"boolean"},"experimental_autoDependenciesHooks":{"type":"array","items":{"type":"string"}},"requireExplicitEffectDeps":{"type":"boolean"}}}]},"react-refresh/only-export-components":{"messages":{"exportAll":"This rule can't verify that `export *` only exports components.","namedExport":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","anonymousExport":"Fast refresh can't handle anonymous components. Add a name to your export.","localComponents":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","noExport":"Fast refresh only works when a file has exports. Move your component(s) to a separate file.","reactContext":"Fast refresh only works when a file only exports components. Move your React context(s) to a separate file."},"type":"problem","schema":[{"type":"object","properties":{"allowExportNames":{"type":"array","items":{"type":"string"}},"allowConstantExport":{"type":"boolean"},"customHOCs":{"type":"array","items":{"type":"string"}},"checkJS":{"type":"boolean"}},"additionalProperties":false}]}}}}